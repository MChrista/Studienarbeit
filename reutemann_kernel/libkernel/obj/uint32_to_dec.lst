     1                                  
     2                                  ;-----------------------------------------------------------------------------
     3                                  ; Section TEXT
     4                                  ;-----------------------------------------------------------------------------
     5                                  SECTION .text
     6                                  
     7                                  
     8                                  ;-------------------------------------------------------------------
     9                                  ; FUNCTION:   uint32_to_dec
    10                                  ;
    11                                  ; PURPOSE:    Convert an unsigned 32-bit integer into its decimal
    12                                  ;             ASCII representation
    13                                  ;
    14                                  ; PARAMETERS: (via register)
    15                                  ;             EAX - value to output as 32-bit unsigned integer
    16                                  ;             EDI - pointer to output string
    17                                  ;             CL  - number of decimal digits
    18                                  ;             CH -  1 -> leading zeros, 0 -> fill with spaces
    19                                  ;
    20                                  ; RETURN:     none
    21                                  ;
    22                                  ;-------------------------------------------------------------------
    23                                         global uint32_to_dec:function
    24                                  uint32_to_dec:
    25 00000000 55                             push    ebp
    26 00000001 89E5                           mov     ebp,esp
    27 00000003 60                             pusha
    28                                  
    29 00000004 0FB6D1                         movzx   edx,cl            ; using the number of decimal digits to output,
    30 00000007 8D72FF                         lea     esi,[edx-1]       ;  load offset relative to buffer pointer in esi
    31 0000000A 89F5                           mov     ebp,esi
    32 0000000C 66BA3000                       mov     dx,'0'
    33 00000010 B120                           mov     cl,' '            ; default fill character
    34 00000012 84ED                           test    ch,ch             ; check whether fill-with-zero flag is zero
    35 00000014 660F45CA                       cmovnz  cx,dx             ;  if not, load '0' as fill character
    36 00000018 85C0                           test    eax,eax           ; check whether number is zero
    37 0000001A 7506                           jnz     .loop_start       ;  if not, convert to string
    38 0000001C 881437                         mov     byte [edi+esi],dl ; otherwise, just write a single 0 into buffer
    39 0000001F 4E                             dec     esi               ;  and adjust the buffer pointer
    40 00000020 EB1E                           jmp     .fill_loop
    41                                  .loop_start:
    42 00000022 BB0A000000                     mov     ebx,10            ; use decimal divisor
    43                                  .div_loop:
    44 00000027 85C0                           test    eax,eax           ; check whether dividend is already zero
    45 00000029 7415                           je      .fill_loop        ;  and if true skip division
    46 0000002B 31D2                           xor     edx,edx           ; clear upper 32-bit of dividend
    47 0000002D F7F3                           div     ebx               ; perform division by ebx = 10
    48 0000002F 80C230                         add     dl,'0'            ;  and convert division remainder to BCD digit
    49 00000032 881437                         mov     [edi+esi],dl      ; write digit into buffer from right to left
    50 00000035 4E                             dec     esi               ; decrement loop counter
    51 00000036 79EF                           jns     .div_loop         ;  down to zero, exit loop if negative
    52                                  
    53 00000038 85C0                           test    eax,eax           ; check whether the number fit into the buffer
    54 0000003A 740A                           jz      .func_end         ;  i.e. whether it is now zero, then continue
    55 0000003C B123                           mov     cl,'#'            ;  otherwise use overflow character
    56 0000003E 89EE                           mov     esi,ebp           ;  and restore original offset to end of buffer
    57                                  .fill_loop:
    58 00000040 880C37                         mov     [edi+esi],cl
    59 00000043 4E                             dec     esi
    60 00000044 79FA                           jns     .fill_loop
    61                                  
    62                                  .func_end:
    63                                         ; restore registers from stack
    64 00000046 61                             popa
    65 00000047 89EC                           mov     esp,ebp
    66 00000049 5D                             pop     ebp
    67 0000004A C3                             ret
    68                                  
