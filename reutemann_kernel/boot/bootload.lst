 GNU assembler version 2.24.51 (i686-linux-gnu)
	 using BFD version (GNU Binutils for Ubuntu) 2.24.90.20141014.
 options passed	: --32 -I../inc -almgns=bootload.lst -c 
 input file    	: bootload.s
 output file   	: bootload.o
 target        	: i686-pc-linux-gnu
 time stamp    	: 2015-05-27T04:55:14.000-0700

   1              	#-----------------------------------------------------------------
   2              	#
   3              	# bootload.s - PC Bootloader for DHBW Kernel
   4              	#
   5              	#
   6              	# Here is a 'boot-loader' that you can use for launching our
   7              	# programming demos and exercises.
   8              	#
   9              	# This boot-loader first demonstrates use of the ROM-BIOS
  10              	# 'Get Memory Size' service (int 0x12) in order to find out
  11              	# the upper limit on memory available for use in real-mode.
  12              	# Then, it loads a chunk of blocks from floppy disk into
  13              	# memory starting at address 0x07E0:0000.
  14              	#
  15              	# If a program with signature word 0xABCD is found at location
  16              	# 0x1000:0000, this program is executed with CS:IP = 0x1000:0002.
  17              	#
  18              	# Otherwise, address 0x1000:0000 is checked for signature string
  19              	# 'DHBW', and if found, the program located there is executed
  20              	# with CS:IP = 0x1000:addr, where the 16-bit start # address
  21              	# 'addr' is stored at location 0x1000:0008.
  22              	#
  23              	#-----------------------------------------------------------------
  24              	# NOTES:
  25              	# This code begins executing with CS:IP = 0x07C0:0000
  26              	#
  27              	#-----------------------------------------------------------------
  28              	# LIMITATIONS:
  29              	# This bootloader assumes a virtual floppy disk, e.g. as provided
  30              	# by qemu. In order to support real floppy drive hardware, drive
  31              	# motor control needs to be added.
  32              	#
  33              	#-----------------------------------------------------------------
  34              	# Author(s): Ralf Reutemann
  35              	#
  36              	# $Id: bootload.s,v 3.0 2014/12/14 12:28:23 ralf Exp ralf $
  37              	#
  38              	#-----------------------------------------------------------------
  39              	# Based on cs630ipl.s and memsize.s written by Allan Cruse,
  40              	# University of San Francisco, Course CS 630, Fall 2008
  41              	#-----------------------------------------------------------------
  42              	
  43              	        #----------------------------------------------------------
  44              	        # generate 16-bit code (x86 'real-mode')
  45              	        #----------------------------------------------------------
  46              	        .code16
  47              	        .section        .text
  48              	
  49              	        #----------------------------------------------------------
  50              	        # Tell the assembler that our code starts at offset 0.
  51              	        # By doing so, our code can easily be relocated by changing
  52              	        # the value of the segment register. This offset can also
  53              	        # be passed to the linker using the -Ttext option.
  54              	        #----------------------------------------------------------
  55              	        .org 0
  56              	
  57              	        .global _start
  58              	_start:
  59              	        #----------------------------------------------------------
  60              	        # We better not rely on any particular value of the code
  61              	        # segment register CS and therefore use a far jump to load
  62              	        # CS and IP with the appropriate values.
  63              	        #----------------------------------------------------------
  64 0000 EA1000C0 	        ljmp   $0x07C0, $mystart
  64      07
  65              	        #----------------------------------------------------------
  66              	        # Bootloader Signature String
  67              	        #----------------------------------------------------------
  68 0005 44484257 	        .ascii  "DHBWBOOT_V3"
  68      424F4F54 
  68      5F5633
  69              	        .align  8
  70              	        #----------------------------------------------------------
  71              	mystart:
  72              	        #----------------------------------------------------------
  73              	        # initialize our stack-pointer for servicing interrupts
  74              	        #----------------------------------------------------------
  75 0010 31C0     	        xor     %ax, %ax                # address lowest arena
  76 0012 8ED0     	        mov     %ax, %ss                #   with SS register
  77 0014 BC007C   	        mov     $0x7C00, %sp            # stack is beneath code
  78              	
  79              	        #----------------------------------------------------------
  80              	        # enable external interrupts
  81              	        #----------------------------------------------------------
  82 0017 FB       	        sti
  83              	
  84              	        #----------------------------------------------------------
  85              	        # setup segment-registers to address our program-data
  86              	        #----------------------------------------------------------
  87 0018 8CC8     	        mov     %cs, %ax                # address program data
  88 001a 8ED8     	        mov     %ax, %ds                # with DS register
  89 001c 8EC0     	        mov     %ax, %es                #   also ES register
  90              	
  91              	        #----------------------------------------------------------
  92              	        # clear the screen
  93              	        #----------------------------------------------------------
  94 001e B40F     	        mov     $0x0F, %ah
  95 0020 CD10     	        int     $0x10
  96 0022 30E4     	        xor     %ah, %ah
  97 0024 CD10     	        int     $0x10
  98              	
  99              	        #----------------------------------------------------------
 100              	        # invoke ROM-BIOS service to obtain memory-size (in KB) and
 101              	        # use repeated division by ten to convert the value found
 102              	        # in AX to a decimal digit-string (without leading zeros)
 103              	        #----------------------------------------------------------
 104 0026 31C0     	        xor     %ax, %ax
 105 0028 CD12     	        int     $0x12                   # get ram's size into AX
 106 002a 721A     	        jc      lmemfail
 107 002c 85C0     	        test    %ax, %ax
 108 002e 7416     	        jz      lmemfail
 109 0030 BB0A00   	        mov     $10, %bx                # divide by 10
 110 0033 BF0500   	        mov     $5, %di                 # initialize buffer-index
 111 0036 31D2     	nxdgt:  xor     %dx, %dx                # extend AX to doubleword
 112 0038 F7F3     	        divw    %bx                     # divide by decimal radix
 113 003a 80C230   	        add     $'0', %dl               # convert number to ascii
 114 003d 4F       	        dec     %di                     # buffer-index moved left
 115 003e 8895A501 	        mov     %dl, mbuf(%di)          # store numeral in buffer
 116 0042 09C0     	        or      %ax, %ax                # was the quotient zero?
 117 0044 75F0     	        jnz     nxdgt                   # no, get another numeral
 118              	lmemfail:
 119              	
 120              	        #----------------------------------------------------------
 121              	        # print boot message
 122              	        #----------------------------------------------------------
 123 0046 8D2E7201 	        lea     bootmsg, %bp            # message offset
 124 004a B93F00   	        mov     $bootmsg_len, %cx       # message length
 125 004d E8CB00   	        call    showmsg
 126              	        #----------------------------------------------------------
 127              	
 128              	        #----------------------------------------------------------
 129              	        # read sectors from floppy disk into memory one single
 130              	        # sector at a time
 131              	        #----------------------------------------------------------
 132 0050 B90100   	        mov     $1, %cx
 133              	readloop:
 134 0053 51       	        push    %cx                     # put parameter on stack
 135 0054 E88000   	        call    read_one_sector
 136 0057 83C402   	        add     $2, %sp                 # remove parameter again
 137 005a 41       	        inc     %cx
 138 005b 81F90002 	        cmp     $512, %cx
 139 005f 76F2     	        jbe     readloop
 140              	
 141              	        #----------------------------------------------------------
 142              	        # check for our application signature
 143              	        #----------------------------------------------------------
 144 0061 C43E3801 	        les     progloc, %di            # point ES:DI to program location
 145 0065 268B4508 	        mov     %es:8(%di), %ax         # load segment start address
 146 0069 26813D44 	        cmpw    $0x4844, %es:(%di)      # check signature word 1 = 'DH'
 146      48
 147 006e 752E     	        jne     check_abcd              #   no, check next signature
 148 0070 26817D02 	        cmpw    $0x5742, %es:2(%di)     # check signature word 2 = 'BW'
 148      4257
 149 0076 7526     	        jne     check_abcd              #   no, check next signature
 150              	
 151              	        #----------------------------------------------------------
 152              	        # print program load message
 153              	        #----------------------------------------------------------
 154 0078 8D2EB101 	        lea     ldmsg, %bp              # message offset
 155 007c B90900   	        mov     $ldmsg_len, %cx         # message length
 156 007f E89900   	        call    showmsg
 157              	
 158              	        #----------------------------------------------------------
 159              	        # print program name stored in signature
 160              	        #----------------------------------------------------------
 161 0082 1E       	        push    %ds                     # save DS on stack
 162 0083 8CC1     	        mov     %es, %cx                # ES points to program location
 163 0085 8ED9     	        mov     %cx, %ds                #   and DS now as well
 164 0087 8D6D18   	        lea     24(%di), %bp            # message-offset in BP
 165 008a 268B4D14 	        mov     %es:20(%di), %cx        # message-length in CX
 166 008e E88A00   	        call    showmsg
 167 0091 1F       	        pop     %ds                     # restore DS from stack
 168              	
 169              	        #----------------------------------------------------------
 170              	        # print CR/LF string
 171              	        #----------------------------------------------------------
 172 0092 8D2E9001 	        lea     crlf, %bp               # message offset
 173 0096 B90400   	        mov     $crlf_len, %cx          # message length
 174 0099 E87F00   	        call    showmsg
 175              	
 176 009c EB0A     	        jmp     load_prog
 177              	
 178              	        #----------------------------------------------------------
 179              	check_abcd:
 180              	        #----------------------------------------------------------
 181              	        # check for orignal USF signature
 182              	        #----------------------------------------------------------
 183 009e 26813DCD 	        cmpw    $0xABCD, %es:(%di)      # our signature there?
 183      AB
 184 00a3 7529     	        jne     inval                   #   no, format not valid
 185 00a5 B80200   	        mov     $2, %ax                 # initialise segment start address
 186              	
 187              	        #----------------------------------------------------------
 188              	        # load program
 189              	        #----------------------------------------------------------
 190              	load_prog:
 191              	        #----------------------------------------------------------
 192              	        # push segment and address offset of return location
 193              	        #----------------------------------------------------------
 194 00a8 0E       	        pushw   %cs
 195 00a9 68AF00   	        pushw   $cleanup
 196              	        #----------------------------------------------------------
 197              	        # push segment and address offset of target location
 198              	        #----------------------------------------------------------
 199 00ac 06       	        pushw   %es
 200 00ad 50       	        pushw   %ax
 201              	        #----------------------------------------------------------
 202              	        # jump to target location
 203              	        #----------------------------------------------------------
 204 00ae CB       	        lret
 205              	        #==========================================================
 206              	
 207              	        #----------------------------------------------------------
 208              	        # return location
 209              	        #----------------------------------------------------------
 210              	cleanup:
 211              	        #----------------------------------------------------------
 212              	        # setup segment-registers to address our program-data
 213              	        #----------------------------------------------------------
 214 00af 8CC8     	        mov     %cs, %ax                # address program data
 215 00b1 8ED8     	        mov     %ax, %ds                # with DS register
 216 00b3 8EC0     	        mov     %ax, %es                #   also ES register
 217              	
 218              	        #----------------------------------------------------------
 219              	        # print 'reboot' message
 220              	        #----------------------------------------------------------
 221 00b5 8D2E4001 	        lea     msg0, %bp               # message offset
 222 00b9 B91500   	        mov     $msg0_len, %cx          # message length
 223              	waitkey:
 224 00bc E85C00   	        call    showmsg
 225              	        #----------------------------------------------------------
 226              	        # await our user's keypress
 227              	        #----------------------------------------------------------
 228 00bf 30E4     	        xor     %ah, %ah                # await keyboard input
 229 00c1 CD16     	        int     $0x16                   # request BIOS service
 230              	
 231              	        #----------------------------------------------------------
 232              	        # invoke the ROM-BIOS reboot service to reboot this PC
 233              	        #----------------------------------------------------------
 234 00c3 CD19     	        int     $0x19
 235              	        #----------------------------------------------------------
 236              	        # REBOOT
 237              	        #----------------------------------------------------------
 238              	
 239              	#------------------------------------------------------------------
 240 00c5 8D2E5501 	rderr:  lea     msg1, %bp               # message offset
 241 00c9 B90C00   	        mov     $msg1_len, %cx          # message length
 242 00cc EBEE     	        jmp     waitkey
 243              	#------------------------------------------------------------------
 244 00ce 8D2E6101 	inval:  lea     msg2, %bp               # message offset
 245 00d2 B91100   	        mov     $msg2_len, %cx          # message length
 246 00d5 EBE5     	        jmp     waitkey
 247              	#------------------------------------------------------------------
 248              	# Parameters:
 249              	#   - "logical" sector number   [bp+4]
 250              	#------------------------------------------------------------------
 251              	# INT 13,2 - Read Disk Sectors
 252              	#
 253              	# AH    = 02
 254              	# AL    = number of sectors to read  (1-128 dec.)
 255              	# CH    = track/cylinder number  (0-1023 dec., see below)
 256              	# CL    = sector number  (1-17 dec.)
 257              	# DH    = head number  (0-15 dec.)
 258              	# DL    = drive number (0=A:, 1=2nd floppy, 80h=drive 0, 81h=drive 1)
 259              	# ES:BX = pointer to buffer
 260              	#
 261              	# Return:
 262              	#  AH   = status  (see INT 13,STATUS)
 263              	#  AL   = number of sectors read
 264              	#  CF   = 0 if successful, 1 if error
 265              	#
 266              	#  - BIOS disk reads should be retrieved at least three times and the
 267              	#    controller should be reset upon error detection
 268              	#  - be sure ES:BX does not cross a 64K segment boundary or a
 269              	#    DMA boundary error will occur
 270              	#  - many programming references list only floppy disk register values
 271              	#  - only the disk number is checked for validity
 272              	#  - the parameters in CX change depending on the number of cylinders;
 273              	#    the track/cylinder number is a 10 bit value taken from the 2 high
 274              	#    order bits of CL and the 8 bits in CH (low order 8 bits of track):
 275              	#
 276              	#    |F|E|D|C|B|A|9|8|7|6|5-0|  CX
 277              	#     | | | | | | | | | |  v-----  sector number
 278              	#     | | | | | | | |  v---------  high order 2 bits of track/cylinder
 279              	#     +-+-+-+-+-+-+-+------------  low order 8 bits of track/cyl number
 280              	#
 281              	#------------------------------------------------------------------
 282              	read_one_sector:
 283 00d7 55       	        push    %bp
 284 00d8 89E5     	        mov     %sp, %bp
 285 00da 60       	        pusha
 286              	
 287              	        #----------------------------------------------------------
 288              	        # Sector = log_sec % SECTORS_PER_TRACK
 289              	        # Head = (log_sec / SECTORS_PER_TRACK) % HEADS
 290              	        # get logical sector number from stack
 291              	        #----------------------------------------------------------
 292 00db 8B4604   	        mov     4(%bp), %ax
 293 00de 31D2     	        xor     %dx, %dx
 294 00e0 BB1200   	        mov     $18, %bx
 295 00e3 F7F3     	        div     %bx
 296 00e5 88163501 	        mov     %dl, sec
 297 00e9 83E001   	        and     $1, %ax
 298 00ec A23701   	        mov     %al, head
 299              	
 300              	        #----------------------------------------------------------
 301              	        # Track = log_sec / (SECTORS_PER_TRACK*HEADS)
 302              	        #----------------------------------------------------------
 303 00ef 8B4604   	        mov     4(%bp), %ax
 304 00f2 31D2     	        xor     %dx, %dx
 305 00f4 BB2400   	        mov     $18*2, %bx
 306 00f7 F7F3     	        div     %bx
 307 00f9 A23601   	        mov     %al, track
 308              	
 309              	        #----------------------------------------------------------
 310              	        # load ES:BX with the start address where the sectors
 311              	        # from floppy disk will be loaded to
 312              	        #----------------------------------------------------------
 313 00fc C41E3C01 	        les     loadloc, %bx
 314              	        #----------------------------------------------------------
 315              	        # ah = 0x02 read disk function
 316              	        # al = 0x01 read a single sector
 317              	        #----------------------------------------------------------
 318 0100 B80102   	        mov     $0x0201, %ax
 319              	        #----------------------------------------------------------
 320              	        # read sector into cl and track into ch, combine
 321              	        # into a single word read
 322              	        #----------------------------------------------------------
 323 0103 8B0E3501 	        mov     sectrack, %cx
 324              	        #----------------------------------------------------------
 325              	        # physical sector number starts at 1, so increment
 326              	        # logical sector number that has been calculated above
 327              	        #----------------------------------------------------------
 328 0107 FEC1     	        inc     %cl
 329 0109 8A363701 	        mov     head, %dh
 330              	        #----------------------------------------------------------
 331              	        # set drive id to zero (floppy drive)
 332              	        #----------------------------------------------------------
 333 010d 30D2     	        xor     %dl, %dl
 334              	        #----------------------------------------------------------
 335              	        # use ROM-BIOS service to read from floppy disk
 336              	        #----------------------------------------------------------
 337 010f CD13     	        int     $0x13
 338              	        #----------------------------------------------------------
 339              	        # CF is set in case of an error
 340              	        #----------------------------------------------------------
 341 0111 72B2     	        jc      rderr                   # error? exit w/message
 342              	
 343              	        #----------------------------------------------------------
 344              	        # increment segmented address by sector size (512 bytes)
 345              	        # start address of a segment is a multiple of 16, therefore
 346              	        # increment segment address by 32 (= 512/16)
 347              	        #----------------------------------------------------------
 348 0113 83063E01 	        addw    $0x20, loadloc+2
 348      20
 349              	
 350 0118 61       	        popa
 351 0119 5D       	        pop     %bp
 352 011a C3       	        ret
 353              	#------------------------------------------------------------------
 354              	showmsg:
 355              	        #----------------------------------------------------------
 356              	        # use ROM-BIOS services to write a message to the screen
 357              	        #----------------------------------------------------------
 358 011b 60       	        pusha
 359 011c 06       	        push    %es
 360 011d 51       	        push    %cx                     # preserve string-length
 361 011e B40F     	        mov     $0x0F, %ah              # get page-number in BH
 362 0120 CD10     	        int     $0x10                   # request BIOS service
 363 0122 B403     	        mov     $0x03, %ah              # get cursor locn in DX
 364 0124 CD10     	        int     $0x10                   # request BIOS service
 365 0126 59       	        pop     %cx                     # recover string-length
 366 0127 8CD8     	        mov     %ds, %ax                # address our variables
 367 0129 8EC0     	        mov     %ax, %es                #   using ES register
 368 012b B30F     	        mov     $0x0f, %bl              # put text colors in BL
 369 012d B80113   	        mov     $0x1301, %ax            # write_string function
 370 0130 CD10     	        int     $0x10                   # request BIOS service
 371 0132 07       	        pop     %es
 372 0133 61       	        popa
 373 0134 C3       	        ret
 374              	
 375              	#------------------------------------------------------------------
 376              	sectrack:           # synonym for word access
 377 0135 00       	sec:    .byte  0    #   will go into cl register
 378 0136 00       	track:  .byte  0    #   will go into ch register
 379 0137 00       	head:   .byte  0
 380              	#------------------------------------------------------------------
 381              	# This bootloader supports loading programs to two different
 382              	# locations in memory, based on a signature word stored in the
 383              	# first two bytes of the program image.
 384              	#
 385              	# Segmented address where to find the program
 386 0138 00000010 	progloc:.word   0x0000, 0x1000          # offset, segment
 387              	#------------------------------------------------------------------
 388              	# This is the segmented address where to load the disk-sectors.
 389              	# NOTE: this segmented address is updated by the load procedure
 390              	# after each read sector, and, finally, points to the memory
 391              	# location following the last loaded byte
 392 013c 0000E007 	loadloc:.word   0x0000, 0x07E0          # offset, segment
 393              	#------------------------------------------------------------------
 394 0140 48697420 	msg0:   .ascii  "Hit any key to reboot"
 394      616E7920 
 394      6B657920 
 394      746F2072 
 394      65626F6F 
 395              	        .equ    msg0_len, (.-msg0)
 396 0155 52656164 	msg1:   .ascii  "Read error\r\n"
 396      20657272 
 396      6F720D0A 
 397              	        .equ    msg1_len, (.-msg1)
 398 0161 5369676E 	msg2:   .ascii  "Signature error\r\n"
 398      61747572 
 398      65206572 
 398      726F720D 
 398      0A
 399              	        .equ    msg2_len, (.-msg2)
 400 0172 0D0A2A2A 	bootmsg:.ascii  "\r\n*** DHBW SNP Boot Loader ***"
 400      2A204448 
 400      42572053 
 400      4E502042 
 400      6F6F7420 
 401 0190 0D0A0D0A 	crlf:   .ascii  "\r\n\r\n"
 402              	        .equ    crlf_len, (.-crlf)
 403 0194 5265616C 	        .ascii  "Real-Mode Memory:"
 403      2D4D6F64 
 403      65204D65 
 403      6D6F7279 
 403      3A
 404 01a5 20202020 	mbuf:   .ascii  "    ? KB\r\n\r\n"      # size to report
 404      3F204B42 
 404      0D0A0D0A 
 405              	        .equ    bootmsg_len, (.-bootmsg)
 406 01b1 53746172 	ldmsg:  .ascii  "Starting "
 406      74696E67 
 406      20
 407              	        .equ    ldmsg_len, (.-ldmsg)
 408              	#------------------------------------------------------------------
 409              	        .end                            # nothing more to assemble
DEFINED SYMBOLS
          bootload.s:58     .text:0000000000000000 _start
          bootload.s:71     .text:0000000000000010 mystart
          bootload.s:118    .text:0000000000000046 lmemfail
          bootload.s:111    .text:0000000000000036 nxdgt
          bootload.s:404    .text:00000000000001a5 mbuf
          bootload.s:400    .text:0000000000000172 bootmsg
                            *ABS*:000000000000003f bootmsg_len
          bootload.s:354    .text:000000000000011b showmsg
          bootload.s:133    .text:0000000000000053 readloop
          bootload.s:282    .text:00000000000000d7 read_one_sector
          bootload.s:386    .text:0000000000000138 progloc
          bootload.s:179    .text:000000000000009e check_abcd
          bootload.s:406    .text:00000000000001b1 ldmsg
                            *ABS*:0000000000000009 ldmsg_len
          bootload.s:401    .text:0000000000000190 crlf
                            *ABS*:0000000000000004 crlf_len
          bootload.s:190    .text:00000000000000a8 load_prog
          bootload.s:244    .text:00000000000000ce inval
          bootload.s:210    .text:00000000000000af cleanup
          bootload.s:394    .text:0000000000000140 msg0
                            *ABS*:0000000000000015 msg0_len
          bootload.s:223    .text:00000000000000bc waitkey
          bootload.s:240    .text:00000000000000c5 rderr
          bootload.s:396    .text:0000000000000155 msg1
                            *ABS*:000000000000000c msg1_len
          bootload.s:398    .text:0000000000000161 msg2
                            *ABS*:0000000000000011 msg2_len
          bootload.s:377    .text:0000000000000135 sec
          bootload.s:379    .text:0000000000000137 head
          bootload.s:378    .text:0000000000000136 track
          bootload.s:392    .text:000000000000013c loadloc
          bootload.s:376    .text:0000000000000135 sectrack

NO UNDEFINED SYMBOLS
