 GNU assembler version 2.24.51 (i686-linux-gnu)
	 using BFD version (GNU Binutils for Ubuntu) 2.24.90.20141014.
 options passed	: --32 -I../inc -almgns=tickdemo.lst -c 
 input file    	: tickdemo.s
 output file   	: tickdemo.o
 target        	: i686-pc-linux-gnu
 time stamp    	: 2015-06-09T09:03:44.000+0200

   1              	//-----------------------------------------------------------------
   2              	//      tickdemo.s
   3              	//
   4              	//      This boot-sector program illustrates basic issues involved
   5              	//      in writing the interrupt-handling procedure for a hardware
   6              	//      device (in this instance the PC's interval timer-counter).
   7              	//      Here we temporarily replace the interrupt-handler provided
   8              	//      by the ROM-BIOS with one of our own design, by overwriting
   9              	//      the appropriate entry in the Interrupt Vector Table.  What
  10              	//      is essential, besides incrementing our 'ticks'variable, is
  11              	//      that (1) an interrupt-handler must issue an EOI command to
  12              	//      the Interrupt Controller, and (2) an interrupt-handler has
  13              	//      to preserve the contents of all the processor's registers.
  14              	//
  15              	//      CAUTION: Something our interrupt-handler neglects to do is
  16              	//      turn off the diskette-drive's motor in case we boot from a
  17              	//      floppy disk, so beware of letting this demo keep running!
  18              	//
  19              	//       assemble with: $ as tickdemo.s -o tickdemo.o
  20              	//       and link with: $ ld tickdemo.o -T ldscript -o tickdemo.b
  21              	//
  22              	//      programmer: ALLAN CRUSE
  23              	//      written on: 31 AUG 2006
  24              	//      revised on: 04 SEP 2008
  25              	//-----------------------------------------------------------------
  26              	
  27              	        .code16                         # for Pentium 'real-mode'
  28              	
  29              	        # manifest constants
  30              	        .equ    seg_base, 0x0000        # segment-address for IVT
  31              	        .equ    seg_boot, 0x07C0        # segment-address of code
  32              	        .equ    seg_vram, 0xB800        # segment-address of VRAM
  33              	
  34              	        .section        .text
  35              	#------------------------------------------------------------------
  36 0000 EA0000C0 	start:  ljmp    $seg_boot, $main        # re-normalize CS and IP
  36      07
  37              	#------------------------------------------------------------------
  38 0005 0000     	ticks:  .word   0                       # keeps count of 'ticks'
  39              	#------------------------------------------------------------------
  40              	isr_tick:  # Interrupt Service Routine for timer-tick interrupts
  41 0007 50       	        push    %ax                     # preverve AX contents
  42 0008 2EFF0605 	        incw    %cs:ticks               # increment tick-count
  42      00
  43 000d B020     	        mov     $0x20, %al              # send 'EOI' command to
  44 000f E620     	        out     %al, $0x20              #  Interrupt Controller
  45 0011 58       	        pop     %ax                     # restore saved register
  46 0012 CF       	        iret                            # return-from-interrupt
  47              	#------------------------------------------------------------------
  48 0013 54696D65 	msg:    .ascii  "Timer-ticks: "         # title for screen-display
  48      722D7469 
  48      636B733A 
  48      20
  49 0020 20202020 	buf:    .ascii  "    0"                 # buffer for 5-digit value
  49      30
  50 0025 1200     	len:    .word   . - msg                 # length of output-message
  51 0027 0E       	hue:    .byte   0x0E                    # colors: yellow-on-black
  52 0028 1300     	src:    .word   msg                     # offset of message source
  53 002a BE07     	dst:    .word   (12*80 + 31)*2          # offset of message dest'n
  54 002c 0A00     	ten:    .word   10                      # radix for decimal-system
  55 002e 00000000 	sav:    .word   0, 0                    # space for storing vector
  56              	#------------------------------------------------------------------
  57              	#------------------------------------------------------------------
  58              	        .global main
  59              	main:   # setup segment-registers DS, ES, FS so that we can access
  60              	        # three memory-regions: our data, the IVT, and the display
  61              	
  62 0032 B8C007   	        mov     $seg_boot, %ax          # address the BOOT_LOCN
  63 0035 8ED8     	        mov     %ax, %ds                #   using register DS
  64              	
  65 0037 B800B8   	        mov     $seg_vram, %ax          # address screen-memory
  66 003a 8EC0     	        mov     %ax, %es                #   using register ES
  67              	
  68 003c B80000   	        mov     $seg_base, %ax          # address vector-table
  69 003f 8EE0     	        mov     %ax, %fs                #   using register FS
  70              	
  71              	        # save the default interrupt-vector for the timer (INT-0x08)
  72              	
  73 0041 64A12000 	        mov     %fs:0x08*4+0, %ax       # copy vector's lo-word
  74 0045 A32E00   	        mov     %ax, sav+0              #  to our save-location
  75 0048 64A12200 	        mov     %fs:0x08*4+2, %ax       # copy vector's hi-word
  76 004c A33000   	        mov     %ax, sav+2              #  to our save-location
  77              	
  78              	        # install a pointer to our own handler in the IVT (INT-0x08)
  79              	
  80 004f FA       	        cli                     # <---- ENTER 'CRITICAL SECTION'
  81 0050 64C70620 	        movw    $isr_tick, %fs:0x08*4+0 # write vector's lo-word
  81      000700
  82 0057 64C70622 	        movw    $seg_boot, %fs:0x08*4+2 # write vector's hi-word
  82      00C007
  83 005e FB       	        sti                     # <---- LEAVE 'CRITICAL SECTION'
  84              	
  85              	        # loop converts 'ticks' to a decimal string and displays it
  86              	        # this loop uses repeated division-by-ten to convert 'ticks'
  87              	        # into its representation as a string of decimal numerals,
  88              	        # then writes our message-string into video screen memory
  89 005f BF0500   	again:  mov     $5, %di                 # point past 5-place buffer
  90 0062 A10500   	        mov     ticks, %ax              # setup the dividend in AX
  91              	nxdiv:  
  92              	        # perform a division of AX by ten 
  93 0065 31D2     	        xor     %dx, %dx                # zero-extend the dividend
  94 0067 F7362C00 	        divw    ten                     # divide (DX,AX) by radix
  95              	
  96              	        # store numeral representing remainder into message-buffer
  97 006b 80C230   	        add     $'0', %dl               # convert remainder to ascii
  98 006e 4F       	        dec     %di                     # move buffer-index leftward
  99 006f 88952000 	        mov     %dl, buf(%di)           # and store the ascii numeral
 100              	
 101              	        # check for possible additional digits
 102 0073 09C0     	        or      %ax, %ax                # did quotient equal zero?
 103 0075 75EE     	        jnz     nxdiv                   # no, generate another digit
 104              	
 105              	        # draw message-text (w/color-attributes) onto the screen
 106 0077 8B362800 	        mov     src, %si                # point DS:SI to the string
 107 007b 8B3E2A00 	        mov     dst, %di                # point ES:DI to the screen
 108 007f 8B0E2500 	        mov     len, %cx                # setup count of characters
 109 0083 8A262700 	        mov     hue, %ah                # and text color-attributes
 110 0087 FC       	        cld                             # forward string-processing
 111 0088 AC       	nxpel:  lodsb                           # fetch next character-byte
 112 0089 AB       	        stosw                           # store char and color-code
 113 008a E2FC     	        loop    nxpel                   # draw the entire message
 114              	
 115              	        # check whether any key has been pressed
 116              	
 117 008c B401     	        mov     $1, %ah                 # peek into keyboard queue
 118 008e CD16     	        int     $0x16                   # request BIOS service
 119 0090 74CD     	        jz      again                   # jump if queue is empty
 120              	
 121              	        # remove that item from the keyboard's input-queue
 122              	
 123 0092 30E4     	        xor     %ah, %ah                # return keyboard entry
 124 0094 CD16     	        int     $0x16                   # request BIOS service
 125              	
 126              	        # check to see if it was the <ESCAPE>-key
 127 0096 3D1B01   	        cmp     $0x011B, %ax            # did user hit <ESCAPE>?
 128 0099 75C4     	        jne     again                   # no, continue this demo
 129              	
 130              	        # restore original interrupt-vector to the IVT (INT-0x08)
 131              	        # [We can do this safely, in a single 'atomic' operation]
 132              	
 133 009b 66A12E00 	        mov     sav+0, %eax             # fetch the saved vector
 134 009f 6466A320 	        mov     %eax, %fs:0x08*4        # put it back in the IVT
 134      00
 135              	
 136              	        # re-boot the machine
 137              	
 138 00a4 CD19     	        int     $0x19                   # request BIOS service
 139              	#------------------------------------------------------------------
 140 00a6 00000000 	        .org    510                     # offset to boot-signature
 140      00000000 
 140      00000000 
 140      00000000 
 140      00000000 
 141 01fe 55AA     	        .byte   0x55, 0xAA              # value for boot-signature
 142              	#------------------------------------------------------------------
 143              	        .end                            # nothing more to assemble
DEFINED SYMBOLS
          tickdemo.s:30     *ABS*:0000000000000000 seg_base
          tickdemo.s:31     *ABS*:00000000000007c0 seg_boot
          tickdemo.s:32     *ABS*:000000000000b800 seg_vram
          tickdemo.s:36     .text:0000000000000000 start
          tickdemo.s:59     .text:0000000000000032 main
          tickdemo.s:38     .text:0000000000000005 ticks
          tickdemo.s:40     .text:0000000000000007 isr_tick
          tickdemo.s:48     .text:0000000000000013 msg
          tickdemo.s:49     .text:0000000000000020 buf
          tickdemo.s:50     .text:0000000000000025 len
          tickdemo.s:51     .text:0000000000000027 hue
          tickdemo.s:52     .text:0000000000000028 src
          tickdemo.s:53     .text:000000000000002a dst
          tickdemo.s:54     .text:000000000000002c ten
          tickdemo.s:55     .text:000000000000002e sav
          tickdemo.s:89     .text:000000000000005f again
          tickdemo.s:91     .text:0000000000000065 nxdiv
          tickdemo.s:111    .text:0000000000000088 nxpel

NO UNDEFINED SYMBOLS
