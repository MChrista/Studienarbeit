 GNU assembler version 2.24.51 (i686-linux-gnu)
	 using BFD version (GNU Binutils for Ubuntu) 2.24.90.20141014.
 options passed	: --32 -I../inc -almgns=pmhello.lst -c 
 input file    	: pmhello.s
 output file   	: pmhello.o
 target        	: i686-pc-linux-gnu
 time stamp    	: 2015-05-26T11:12:45.000-0700

   1              	#-----------------------------------------------------------------
   2              	# pmhello.s
   3              	#
   4              	# This program prints a simple welcome message to the screen and
   5              	# triggers an exception by calling an unhandled interrupt.
   6              	#
   7              	#-----------------------------------------------------------------
   8              	
   9              	
  10              	#==================================================================
  11              	# S I G N A T U R E
  12              	#==================================================================
  13              	        .section        .signature, "a", @progbits
  14 0000 07000000 	        .long   progname_size
  15              	progname:
  16 0004 504D4845 	        .ascii  "PMHELLO"
  16      4C4C4F
  17              	        .equ    progname_size, (.-progname)
  18 000b 00       	        .byte   0
  19              	
  20              	
  21              	#==================================================================
  22              	# S E C T I O N   D A T A
  23              	#==================================================================
  24              	
  25              	        .section        .data
  26              	
  27              	        .equ    DATA_START, 0x20000
  28              	
  29              	#------------------------------------------------------------------
  30              	# G L O B A L   D E S C R I P T O R   T A B L E
  31              	#------------------------------------------------------------------
  32              	        .align  16
  33              	        .global theGDT
  34              	theGDT:
  35              	        .include "comgdt.inc"
   1              	
   2 0000 00000000 	        .quad   0x0000000000000000      # null segment-descriptor
   2      00000000 
   3              	        #----------------------------------------------------------
   4              	        # Code/Data, 32 bit, 4kB, Priv 0, Type 0x02, 'Read/Write'
   5              	        # Base Address: 0x00000000   Limit: 0x000fffff
   6 0008 FFFF0000 	        .quad   0x00CF92000000FFFF      # code segment-descriptor
   6      0092CF00 
   7              	        #----------------------------------------------------------
   8              	        # Call Gate, 32-bit, Ring 0
   9              	        .equ    selPM32, (.-theGDT)+0   # selector for call-gate
  10              	        .global selPM32
  11 0010 00000000 	        .word   pm_enter, privCS, 0x8C00, 0x0000 # gate-descriptor
  11      008C0000 
  12              	        #----------------------------------------------------------
  13              	        # Call Gate, 16-bit, Ring 0
  14              	        .equ    selRM16, (.-theGDT)+0   # selector for call-gate
  15              	        .global selRM16
  16 0018 00000000 	        .word   rm_enter, sel_cs, 0x8400, 0x0000 # gate-descriptor
  16      00840000 
  17              	        #----------------------------------------------------------
  18              	        # Call Gate, 32-bit, Ring 3
  19              	        .equ    selUsr, (.-theGDT)+3   # selector for call-gate
  20              	        .global selUsr
  21 0020 00000000 	        .word   bail_out, privCS, 0xEC00, 0x0000 # gate-descriptor
  21      00EC0000 
  22              	        #----------------------------------------------------------
  23              	        # Code/Data, 16 bit, Byte, Priv 0, Type 0x0a, 'Execute/Read'
  24              	        # Base Address: 0x00010000   Limit: 0x0000FFFF
  25              	        .equ    sel_cs, (.-theGDT)+0    # selector for 16bit code
  26              	        .global sel_cs
  27 0028 FFFF0000 	        .quad   0x00009A010000FFFF      # code segment-descriptor
  27      019A0000 
  28              	        #----------------------------------------------------------
  29              	        # Code/Data, 16 bit, Byte, Priv 0, Type 0x02, 'Read/Write'
  30              	        # Base Address: 0x00020000   Limit: 0x0000FFFF
  31              	        .equ    sel_ds, (.-theGDT)+0    # selector for 16bit data
  32              	        .global sel_ds
  33 0030 FFFF0000 	        .quad   0x000092020000FFFF      # data segment-descriptor
  33      02920000 
  34              	        #----------------------------------------------------------
  35              	        # Code/Data, 16 bit, Byte, Priv 0, Type 0x02, 'Read/Write'
  36              	        # Base Address: 0x000b8000   Limit: 0x00007FFF
  37              	        # Used to access CGA Display RAM
  38              	        .equ    sel_es, (.-theGDT)+0    # selector for video area
  39              	        .global sel_es
  40 0038 FF7F0080 	        .quad   0x0000920B80007fff      # vram segment-descriptor
  40      0B920000 
  41              	        #----------------------------------------------------------
  42              	        # Code/Data, 16 bit, Byte, Priv 0, Type 0x02, 'Read/Write'
  43              	        # Base Address: 0x00000400   Limit: 0x000000FF
  44              	        .equ    sel_bs, (.-theGDT)+0    # selector for BIOS data
  45              	        .global sel_bs
  46 0040 FF000004 	        .quad   0x00009200040000ff      # data segment-descriptor
  46      00920000 
  47              	        #----------------------------------------------------------
  48              	        # Code/Data, 32 bit, Byte, Priv 0, Type 0x0a, 'Execute/Read'
  49              	        # Base Address: 0x00010000   Limit: 0x0000FFFF
  50              	        .equ    privCS, (.-theGDT)+0    # selector for ring0 code
  51              	        .global privCS
  52 0048 FFFF0000 	        .quad   0x00409A010000FFFF      # code segment-descriptor
  52      019A4000 
  53              	        #----------------------------------------------------------
  54              	        # Code/Data, 32 bit, Byte, Priv 0, Type 0x02, 'Read/Write'
  55              	        # Base Address: 0x00020000   Limit: 0x0000FFFF
  56              	        .equ    privDS, (.-theGDT)+0    # selector for ring0 data
  57              	        .global privDS
  58 0050 FFFF0000 	        .quad   0x004092020000FFFF      # data segment-descriptor
  58      02924000 
  59              	        #----------------------------------------------------------
  60              	        # Expand-Up Stack Segment Descriptor
  61              	        # Code/Data, 32 bit, Byte, Priv 0, Type 0x02, 'Read/Write'
  62              	        # Base Address: 0x0000C000   Limit: 0x00003FFF
  63              	        .equ    privSS, (.-theGDT)+0    # selector for ring0 data
  64              	        .global privSS
  65 0058 FF3F00C0 	        .quad   0x00409200C0003FFF      # stack segment-descriptor
  65      00924000 
  66              	        #----------------------------------------------------------
  67              	
  36              	        #----------------------------------------------------------
  37              	        .equ    limGDT, (. - theGDT)-1  # our GDT's segment-limit
  38              	#------------------------------------------------------------------
  39              	        # image for GDTR register
  40              	        .align  16
  41              	        .global regGDT
  42 0060 5F00     	regGDT: .word   limGDT
  43 0062 00000200 	        .long   theGDT+DATA_START       # create linear address
  44              	#------------------------------------------------------------------
  45              	# I N T E R R U P T   D E S C R I P T O R   T A B L E
  46              	#------------------------------------------------------------------
  47 0066 00000000 	        .align  16
  47      00000000 
  47      0000
  48              	        .global theIDT
  49              	        #----------------------------------------------------------
  50              	theIDT: # allocate 256 gate-descriptors
  51              	        #----------------------------------------------------------
  52 0070 00000000 	        .quad   0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
  52      00000000 
  52      00000000 
  52      00000000 
  52      00000000 
  53              	        #----------------------------------------------------------
  54              	        # General Protection Exception (0x0D) gate descriptor
  55              	        #----------------------------------------------------------
  56 00d8 00004800 	        .word   isrGPF, privCS, 0x8E00, 0x0000
  56      008E0000 
  57              	        #----------------------------------------------------------
  58              	        # allocate free space for the remaining unused descriptors
  59              	        #----------------------------------------------------------
  60 00e0 00000000 	        .zero   256*8 - (.-theIDT)
  60      00000000 
  60      00000000 
  60      00000000 
  60      00000000 
  61              	        .equ    limIDT, (.-theIDT)-1    # this IDT's segment_limit
  62              	#------------------------------------------------------------------
  63              	        # image for IDTR register
  64              	        .align  16
  65              	        .global regIDT
  66 0870 FF07     	regIDT: .word   limIDT
  67 0872 00000200 	        .long   theIDT+DATA_START       # create linear address
  68              	#------------------------------------------------------------------
  69 0876 2048656C 	pmmsg:  .ascii  " Hello from protected mode "   # message's text
  69      6C6F2066 
  69      726F6D20 
  69      70726F74 
  69      65637465 
  70 0891 1B000000 	pmlen:  .long  . - pmmsg                # size of message string
  71              	
  72              	#==================================================================
  73              	        .section        .text
  74              	        .code32
  75              	#------------------------------------------------------------------
  76              	# M A I N   F U N C T I O N
  77              	#------------------------------------------------------------------
  78              	        .type   main, @function
  79              	        .global main
  80              	main:
  81 0000 C8000000 	        enter   $0, $0
  82              	        #pushal
  83              	
  84              	        #----------------------------------------------------------
  85              	        # Segment register usage (provided by start.o):
  86              	        #   CS - Code Segment
  87              	        #   DS - Data Segment
  88              	        #   SS - Stack Segment
  89              	        #   ES - CGA Video Memory
  90              	        #----------------------------------------------------------
  91              	
  92              	        #----------------------------------------------------------
  93              	        # copy message string to video memory
  94              	        #----------------------------------------------------------
  95 0004 8D357608 	        lea     pmmsg, %esi             # point DS:ESI to message string
  95      0000
  96 000a BF000500 	        mov     $8*160, %edi            # point ES:EDI to screen
  96      00
  97 000f B42E     	        mov     $0x2E, %ah              # color attribute: yellow on green
  98 0011 8B0D9108 	        mov     pmlen, %ecx             # string's length in CX
  98      0000
  99 0017 FC       	        cld                             # do forward processing
 100 0018 AC       	nxchr1: lodsb                           # fetch next character
 101 0019 66AB     	        stosw                           # store char and color
 102 001b E2FB     	        loop    nxchr1                  # again if chars remain
 103              	        #----------------------------------------------------------
 104              	
 105 001d 8D350000 	        lea     hex_digits, %esi
 105      0000
 106 0023 BF400600 	        mov     $10*160, %edi            # point ES:EDI to screen
 106      00
 107 0028 B40F     	        mov     $0x0f, %ah
 108 002a B9100000 	        mov     $16, %ecx
 108      00
 109              	nxchr2:
 110 002f AC       	        lodsb
 111 0030 66AB     	        stosw
 112 0032 E2FB     	        loop    nxchr2
 113              	
 114 0034 BFE00600 	        mov     $11*160, %edi            # point ES:EDI to screen
 114      00
 115 0039 66B82000 	        mov     $0x0020, %ax
 116 003d B9100000 	        mov     $16, %ecx
 116      00
 117              	nxchr3:
 118 0042 66AB     	        stosw
 119 0044 80C410   	        add     $0x10, %ah
 120 0047 E2F9     	        loop    nxchr3
 121              	
 122 0049 8D350000 	        lea     hex_digits, %esi
 122      0000
 123 004f BF800700 	        mov     $12*160, %edi            # point ES:EDI to screen
 123      00
 124 0054 66B82000 	        mov     $0x0020, %ax
 125 0058 B9100000 	        mov     $16, %ecx
 125      00
 126              	nxchr4:
 127 005d AC       	        lodsb
 128 005e 66AB     	        stosw
 129 0060 80C401   	        add     $0x01, %ah
 130 0063 E2F8     	        loop    nxchr4
 131              	
 132              	        #----------------------------------------------------------
 133              	        # initialise registers to some values
 134              	        #----------------------------------------------------------
 135 0065 B8785634 	        mov     $0x12345678, %eax
 135      12
 136 006a BBA5A5A5 	        mov     $0xa5a5a5a5, %ebx
 136      A5
 137 006f B95A5A5A 	        mov     $0x5a5a5a5a, %ecx
 137      5A
 138 0074 BEBAABBA 	        mov     $0xabbaabba, %esi
 138      AB
 139 0079 BFBEEBBE 	        mov     $0xebbeebbe, %edi
 139      EB
 140 007e 68333333 	        pushl   $0x33333333
 140      33
 141 0083 68222222 	        pushl   $0x22222222
 141      22
 142 0088 68111111 	        pushl   $0x11111111
 142      11
 143              	        #----------------------------------------------------------
 144              	        # raise an unhandled interrupt to generate a GPF
 145              	        #----------------------------------------------------------
 146 008d CD01     	        int     $1
 147              	
 148              	        #popal
 149 008f C9       	        leave
 150 0090 C3       	        ret
 151              	#------------------------------------------------------------------
 152              	        .type   bail_out, @function
 153              	        .global bail_out
 154              	bail_out:
 155 0091 FA       	        cli
 156 0092 F4       	        hlt
 157              	#------------------------------------------------------------------
 158              	        .end
DEFINED SYMBOLS
                            *ABS*:0000000000000007 progname_size
           pmhello.s:15     .signature:0000000000000004 progname
           pmhello.s:27     *ABS*:0000000000020000 DATA_START
           pmhello.s:34     .data:0000000000000000 theGDT
   ../inc/comgdt.inc:9      *ABS*:0000000000000010 selPM32
                            *ABS*:0000000000000048 privCS
   ../inc/comgdt.inc:14     *ABS*:0000000000000018 selRM16
                            *ABS*:0000000000000028 sel_cs
   ../inc/comgdt.inc:19     *ABS*:0000000000000023 selUsr
           pmhello.s:154    .text:0000000000000091 bail_out
   ../inc/comgdt.inc:31     *ABS*:0000000000000030 sel_ds
   ../inc/comgdt.inc:38     *ABS*:0000000000000038 sel_es
   ../inc/comgdt.inc:44     *ABS*:0000000000000040 sel_bs
   ../inc/comgdt.inc:56     *ABS*:0000000000000050 privDS
   ../inc/comgdt.inc:63     *ABS*:0000000000000058 privSS
           pmhello.s:37     *ABS*:000000000000005f limGDT
           pmhello.s:42     .data:0000000000000060 regGDT
           pmhello.s:50     .data:0000000000000070 theIDT
           pmhello.s:61     *ABS*:00000000000007ff limIDT
           pmhello.s:66     .data:0000000000000870 regIDT
           pmhello.s:69     .data:0000000000000876 pmmsg
           pmhello.s:70     .data:0000000000000891 pmlen
           pmhello.s:80     .text:0000000000000000 main
           pmhello.s:100    .text:0000000000000018 nxchr1
           pmhello.s:109    .text:000000000000002f nxchr2
           pmhello.s:117    .text:0000000000000042 nxchr3
           pmhello.s:126    .text:000000000000005d nxchr4

UNDEFINED SYMBOLS
pm_enter
rm_enter
isrGPF
hex_digits
