 GNU assembler version 2.24.51 (i686-linux-gnu)
	 using BFD version (GNU Binutils for Ubuntu) 2.24.90.20141014.
 options passed	: --32 -I../inc -almgns=pgftdemo.lst -c 
 input file    	: pgftdemo.s
 output file   	: pgftdemo.o
 target        	: i686-pc-linux-gnu
 time stamp    	: 2015-05-26T11:12:45.000-0700

   1              	#-----------------------------------------------------------------
   2              	# pgftdemo.s
   3              	#
   4              	#-----------------------------------------------------------------
   5              	
   6              	
   7              	#==================================================================
   8              	# S I G N A T U R E
   9              	#==================================================================
  10              	        .section        .signature, "a", @progbits
  11 0000 08000000 	        .long   progname_size
  12              	progname:
  13 0004 50474654 	        .ascii  "PGFTDEMO"
  13      44454D4F 
  14              	        .equ    progname_size, (.-progname)
  15 000c 00       	        .byte   0
  16              	
  17              	
  18              	#==================================================================
  19              	# S E C T I O N   D A T A
  20              	#==================================================================
  21              	
  22              	        .section        .data
  23              	
  24              	        .equ    DATA_START, 0x20000
  25              	
  26              	#------------------------------------------------------------------
  27              	# G L O B A L   D E S C R I P T O R   T A B L E
  28              	#------------------------------------------------------------------
  29              	        .align  16
  30              	        .global theGDT
  31              	theGDT:
  32              	        .include "comgdt.inc"
   1              	
   2 0000 00000000 	        .quad   0x0000000000000000      # null segment-descriptor
   2      00000000 
   3              	        #----------------------------------------------------------
   4              	        # Code/Data, 32 bit, 4kB, Priv 0, Type 0x02, 'Read/Write'
   5              	        # Base Address: 0x00000000   Limit: 0x000fffff
   6 0008 FFFF0000 	        .quad   0x00CF92000000FFFF      # code segment-descriptor
   6      0092CF00 
   7              	        #----------------------------------------------------------
   8              	        # Call Gate, 32-bit, Ring 0
   9              	        .equ    selPM32, (.-theGDT)+0   # selector for call-gate
  10              	        .global selPM32
  11 0010 00000000 	        .word   pm_enter, privCS, 0x8C00, 0x0000 # gate-descriptor
  11      008C0000 
  12              	        #----------------------------------------------------------
  13              	        # Call Gate, 16-bit, Ring 0
  14              	        .equ    selRM16, (.-theGDT)+0   # selector for call-gate
  15              	        .global selRM16
  16 0018 00000000 	        .word   rm_enter, sel_cs, 0x8400, 0x0000 # gate-descriptor
  16      00840000 
  17              	        #----------------------------------------------------------
  18              	        # Call Gate, 32-bit, Ring 3
  19              	        .equ    selUsr, (.-theGDT)+3   # selector for call-gate
  20              	        .global selUsr
  21 0020 00000000 	        .word   bail_out, privCS, 0xEC00, 0x0000 # gate-descriptor
  21      00EC0000 
  22              	        #----------------------------------------------------------
  23              	        # Code/Data, 16 bit, Byte, Priv 0, Type 0x0a, 'Execute/Read'
  24              	        # Base Address: 0x00010000   Limit: 0x0000FFFF
  25              	        .equ    sel_cs, (.-theGDT)+0    # selector for 16bit code
  26              	        .global sel_cs
  27 0028 FFFF0000 	        .quad   0x00009A010000FFFF      # code segment-descriptor
  27      019A0000 
  28              	        #----------------------------------------------------------
  29              	        # Code/Data, 16 bit, Byte, Priv 0, Type 0x02, 'Read/Write'
  30              	        # Base Address: 0x00020000   Limit: 0x0000FFFF
  31              	        .equ    sel_ds, (.-theGDT)+0    # selector for 16bit data
  32              	        .global sel_ds
  33 0030 FFFF0000 	        .quad   0x000092020000FFFF      # data segment-descriptor
  33      02920000 
  34              	        #----------------------------------------------------------
  35              	        # Code/Data, 16 bit, Byte, Priv 0, Type 0x02, 'Read/Write'
  36              	        # Base Address: 0x000b8000   Limit: 0x00007FFF
  37              	        # Used to access CGA Display RAM
  38              	        .equ    sel_es, (.-theGDT)+0    # selector for video area
  39              	        .global sel_es
  40 0038 FF7F0080 	        .quad   0x0000920B80007fff      # vram segment-descriptor
  40      0B920000 
  41              	        #----------------------------------------------------------
  42              	        # Code/Data, 16 bit, Byte, Priv 0, Type 0x02, 'Read/Write'
  43              	        # Base Address: 0x00000400   Limit: 0x000000FF
  44              	        .equ    sel_bs, (.-theGDT)+0    # selector for BIOS data
  45              	        .global sel_bs
  46 0040 FF000004 	        .quad   0x00009200040000ff      # data segment-descriptor
  46      00920000 
  47              	        #----------------------------------------------------------
  48              	        # Code/Data, 32 bit, Byte, Priv 0, Type 0x0a, 'Execute/Read'
  49              	        # Base Address: 0x00010000   Limit: 0x0000FFFF
  50              	        .equ    privCS, (.-theGDT)+0    # selector for ring0 code
  51              	        .global privCS
  52 0048 FFFF0000 	        .quad   0x00409A010000FFFF      # code segment-descriptor
  52      019A4000 
  53              	        #----------------------------------------------------------
  54              	        # Code/Data, 32 bit, Byte, Priv 0, Type 0x02, 'Read/Write'
  55              	        # Base Address: 0x00020000   Limit: 0x0000FFFF
  56              	        .equ    privDS, (.-theGDT)+0    # selector for ring0 data
  57              	        .global privDS
  58 0050 FFFF0000 	        .quad   0x004092020000FFFF      # data segment-descriptor
  58      02924000 
  59              	        #----------------------------------------------------------
  60              	        # Expand-Up Stack Segment Descriptor
  61              	        # Code/Data, 32 bit, Byte, Priv 0, Type 0x02, 'Read/Write'
  62              	        # Base Address: 0x0000C000   Limit: 0x00003FFF
  63              	        .equ    privSS, (.-theGDT)+0    # selector for ring0 data
  64              	        .global privSS
  65 0058 FF3F00C0 	        .quad   0x00409200C0003FFF      # stack segment-descriptor
  65      00924000 
  66              	        #----------------------------------------------------------
  67              	
  33              	        #----------------------------------------------------------
  34              	        .equ    limGDT, (. - theGDT)-1  # our GDT's segment-limit
  35              	#------------------------------------------------------------------
  36              	        # image for GDTR register
  37              	        .align  16
  38              	        .global regGDT
  39 0060 5F00     	regGDT: .word   limGDT
  40 0062 00000200 	        .long   theGDT+DATA_START       # create linear address
  41              	#------------------------------------------------------------------
  42              	# I N T E R R U P T   D E S C R I P T O R   T A B L E
  43              	#------------------------------------------------------------------
  44 0066 00000000 	        .align  16
  44      00000000 
  44      0000
  45              	        .global theIDT
  46              	        #----------------------------------------------------------
  47              	theIDT: # allocate 256 gate-descriptors
  48              	        #----------------------------------------------------------
  49 0070 00000000 	        .quad   0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
  49      00000000 
  49      00000000 
  49      00000000 
  49      00000000 
  50              	        #----------------------------------------------------------
  51              	        # General Protection Exception (0x0D) gate descriptor
  52              	        #----------------------------------------------------------
  53 00d8 00004800 	        .word   isrGPF, privCS, 0x8E00, 0x0000
  53      008E0000 
  54              	        #----------------------------------------------------------
  55              	        # allocate free space for the remaining unused descriptors
  56              	        #----------------------------------------------------------
  57 00e0 00000000 	        .zero   256*8 - (.-theIDT)
  57      00000000 
  57      00000000 
  57      00000000 
  57      00000000 
  58              	        .equ    limIDT, (.-theIDT)-1    # this IDT's segment_limit
  59              	
  60              	        #----------------------------------------------------------
  61              	        # image for IDTR register
  62              	        #----------------------------------------------------------
  63              	        .align  16
  64              	        .global regIDT
  65 0870 FF07     	regIDT: .word   limIDT
  66 0872 00000200 	        .long   theIDT+DATA_START       # create linear address
  67              	
  68              	#------------------------------------------------------------------
  69              	
  70              	        #----------------------------------------------------------
  71              	        # output string for page fault result structure
  72              	        #----------------------------------------------------------
  73 0876 5F5F5F5F 	pgftmsg:.ascii  "________ "             # faulting address
  73      5F5F5F5F 
  73      20
  74 087f 5044453A 	        .ascii  "PDE:___ "
  74      5F5F5F20 
  75 0887 5054453A 	        .ascii  "PTE:___ "
  75      5F5F5F20 
  76 088f 4F46463A 	        .ascii  "OFF:___ "
  76      5F5F5F20 
  77 0897 5F5F5F5F 	        .ascii  "________ "
  77      5F5F5F5F 
  77      20
  78 08a0 5F5F5F5F 	        .ascii  "____\n"
  78      0A
  79              	        .equ    pgftmsg_len, (.-pgftmsg)
  80              	
  81              	        #----------------------------------------------------------
  82              	        # address samples
  83              	        #----------------------------------------------------------
  84 08a5 00000100 	samples:.long   0x00010000, 0x000100ff, 0x00020000, 0x00020abc
  84      FF000100 
  84      00000200 
  84      BC0A0200 
  85 08b5 00800B00 	        .long   0x000B8000, 0x000110ff, 0x08048000, 0x08048000
  85      FF100100 
  85      00800408 
  85      00800408 
  86 08c5 FCFFFFFF 	        .long   0xfffffffc, 0x08000000, 0x08048123, 0x08049321
  86      00000008 
  86      23810408 
  86      21930408 
  87 08d5 001C0508 	        .long   0x08051c00, 0x08050abc, 0x60000000, 0x08048fff
  87      BC0A0508 
  87      00000060 
  87      FF8F0408 
  88 08e5 04900408 	        .long   0x08049004, 0x00000000
  88      00000000 
  89              	
  90              	
  91              	#==================================================================
  92              	        .section        .text
  93              	        .code32
  94              	#------------------------------------------------------------------
  95              	# M A I N   F U N C T I O N
  96              	#------------------------------------------------------------------
  97              	        .type   main, @function
  98              	        .global main
  99              	        .extern pfhandler
 100              	        .extern int_to_hex
 101              	        .extern screen_write
 102              	        .extern screen_sel_page
 103              	main:
 104 0000 C8000000 	        enter   $0, $0
 105 0004 60       	        pushal
 106              	
 107              	        #----------------------------------------------------------
 108              	        # Segment register usage (provided by start.o):
 109              	        #   CS - Code Segment
 110              	        #   DS - Data Segment
 111              	        #   SS - Stack Segment
 112              	        #   ES - CGA Video Memory
 113              	        #----------------------------------------------------------
 114              	
 115 0005 31C0     	        xor     %eax, %eax
 116 0007 E8FCFFFF 	        call    screen_sel_page
 116      FF
 117              	        #----------------------------------------------------------
 118              	        # read address samples from array
 119              	        # end of array is indicated by zero address
 120              	        #----------------------------------------------------------
 121 000c 31C9     	        xor     %ecx, %ecx
 122              	read_samples:
 123 000e 8B048DA5 	        mov     samples(,%ecx,4), %eax
 123      080000
 124 0015 85C0     	        test    %eax, %eax
 125 0017 0F849400 	        jz      read_done
 125      0000
 126 001d 51       	        pushl   %ecx
 127              	
 128 001e 50       	        pushl   %eax
 129 001f E8FCFFFF 	        call    pfhandler
 129      FF
 130 0024 83C404   	        add     $4, %esp
 131 0027 89C6     	        mov     %eax, %esi
 132              	
 133              	        #----------------------------------------------------------
 134              	        # Convert 32-bit integers to hex strings
 135              	        # eax - value to output as 32-bit unsigned integer
 136              	        # edi - pointer to output string
 137              	        # ecx - number of output digits
 138              	        #----------------------------------------------------------
 139 0029 8B06     	        mov     (%esi), %eax      # faulting address
 140 002b 8D3D7608 	        lea     pgftmsg, %edi
 140      0000
 141 0031 B9080000 	        mov     $8, %ecx
 141      00
 142 0036 E8FCFFFF 	        call    int_to_hex
 142      FF
 143              	
 144 003b 8B4604   	        mov     4(%esi), %eax     # PDE
 145 003e 8D3D8308 	        lea     pgftmsg+13, %edi
 145      0000
 146 0044 B9030000 	        mov     $3, %ecx
 146      00
 147 0049 E8FCFFFF 	        call    int_to_hex
 147      FF
 148              	
 149 004e 8B4608   	        mov     8(%esi), %eax     # PTE
 150 0051 8D3D8B08 	        lea     pgftmsg+21, %edi
 150      0000
 151 0057 B9030000 	        mov     $3, %ecx
 151      00
 152 005c E8FCFFFF 	        call    int_to_hex
 152      FF
 153              	
 154 0061 8B460C   	        mov     12(%esi), %eax    # address offset
 155 0064 8D3D9308 	        lea     pgftmsg+29, %edi
 155      0000
 156 006a B9030000 	        mov     $3, %ecx
 156      00
 157 006f E8FCFFFF 	        call    int_to_hex
 157      FF
 158              	
 159 0074 8B4610   	        mov     16(%esi), %eax    # physical address
 160 0077 8D3D9708 	        lea     pgftmsg+33, %edi
 160      0000
 161 007d B9080000 	        mov     $8, %ecx
 161      00
 162 0082 E8FCFFFF 	        call    int_to_hex
 162      FF
 163              	
 164 0087 8B4614   	        mov     20(%esi), %eax    # flags
 165 008a 8D3DA008 	        lea     pgftmsg+42, %edi
 165      0000
 166 0090 B9040000 	        mov     $4, %ecx
 166      00
 167 0095 E8FCFFFF 	        call    int_to_hex
 167      FF
 168              	
 169 009a 8D357608 	        lea     pgftmsg, %esi           # message-offset into ESI
 169      0000
 170 00a0 B92F0000 	        mov     $pgftmsg_len, %ecx      # message-length into ECX
 170      00
 171 00a5 E8FCFFFF 	        call    screen_write
 171      FF
 172 00aa 59       	        popl    %ecx
 173 00ab 41       	        inc     %ecx
 174 00ac E95DFFFF 	        jmp     read_samples
 174      FF
 175              	read_done:
 176              	
 177 00b1 61       	        popal
 178 00b2 C9       	        leave
 179 00b3 C3       	        ret
 180              	#------------------------------------------------------------------
 181              	        .type   bail_out, @function
 182              	        .global bail_out
 183              	bail_out:
 184 00b4 FA       	        cli
 185 00b5 F4       	        hlt
 186              	#------------------------------------------------------------------
 187              	        .end
DEFINED SYMBOLS
                            *ABS*:0000000000000008 progname_size
          pgftdemo.s:12     .signature:0000000000000004 progname
          pgftdemo.s:24     *ABS*:0000000000020000 DATA_START
          pgftdemo.s:31     .data:0000000000000000 theGDT
   ../inc/comgdt.inc:9      *ABS*:0000000000000010 selPM32
                            *ABS*:0000000000000048 privCS
   ../inc/comgdt.inc:14     *ABS*:0000000000000018 selRM16
                            *ABS*:0000000000000028 sel_cs
   ../inc/comgdt.inc:19     *ABS*:0000000000000023 selUsr
          pgftdemo.s:183    .text:00000000000000b4 bail_out
   ../inc/comgdt.inc:31     *ABS*:0000000000000030 sel_ds
   ../inc/comgdt.inc:38     *ABS*:0000000000000038 sel_es
   ../inc/comgdt.inc:44     *ABS*:0000000000000040 sel_bs
   ../inc/comgdt.inc:56     *ABS*:0000000000000050 privDS
   ../inc/comgdt.inc:63     *ABS*:0000000000000058 privSS
          pgftdemo.s:34     *ABS*:000000000000005f limGDT
          pgftdemo.s:39     .data:0000000000000060 regGDT
          pgftdemo.s:47     .data:0000000000000070 theIDT
          pgftdemo.s:58     *ABS*:00000000000007ff limIDT
          pgftdemo.s:65     .data:0000000000000870 regIDT
          pgftdemo.s:73     .data:0000000000000876 pgftmsg
          pgftdemo.s:79     *ABS*:000000000000002f pgftmsg_len
          pgftdemo.s:84     .data:00000000000008a5 samples
          pgftdemo.s:103    .text:0000000000000000 main
          pgftdemo.s:122    .text:000000000000000e read_samples
          pgftdemo.s:175    .text:00000000000000b1 read_done

UNDEFINED SYMBOLS
pm_enter
rm_enter
isrGPF
screen_sel_page
pfhandler
int_to_hex
screen_write
