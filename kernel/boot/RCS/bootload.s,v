head	2.0;
access;
symbols;
locks
	ralf:2.0; strict;
comment	@# @;


2.0
date	2014.10.03.18.59.34;	author ralf;	state Exp;
branches;
next	1.7;

1.7
date	2014.03.30.07.55.33;	author ralf;	state Exp;
branches;
next	1.6;

1.6
date	2014.03.17.15.30.56;	author ralf;	state Exp;
branches;
next	1.5;

1.5
date	2014.03.06.11.14.40;	author ralf;	state Exp;
branches;
next	1.4;

1.4
date	2014.03.05.17.09.57;	author ralf;	state Exp;
branches;
next	1.3;

1.3
date	2014.02.16.14.08.33;	author ralf;	state Exp;
branches;
next	1.2;

1.2
date	2014.02.02.00.25.04;	author ralf;	state Exp;
branches;
next	1.1;

1.1
date	2008.09.09.15.36.41;	author ralf;	state Exp;
branches;
next	;


desc
@Boot-loader based on cs630ipl.s and memsize.s written by
Prof. Allan Cruse, University of San Francisco,
Course CS 630, Fall 2008.
@


2.0
log
@Changed signatures of programs to be loaded.
@
text
@#-----------------------------------------------------------------
#
# bootload.s - PC Bootloader for DHBW Kernel
#
#
# Here is a 'boot-loader' that you can use for launching our
# programming demos and exercises.
#
# This boot-loader first demonstrates use of the ROM-BIOS
# 'Get Memory Size' service (int 0x12) in order to find out
# the upper limit on memory available for use in real-mode.
# Then, it loads a chunk of blocks from floppy disk into
# memory starting at address 0x07E0:0000.
#
# If a program with signature word 0xBEEF is found at this
# location, this program is executed with CS:IP = 0x07E0:0010.
#
# Otherwise, address 0x1000:0000 is checked for signature
# word 0xCAFE, and if found, the program located there is
# executed with CS:IP = 0x1000:addr, where the 16-bit start
# address 'addr' is stored at location 0x1000:0002.
#
#-----------------------------------------------------------------
# NOTES:
# This code begins executing with CS:IP = 0x07C0:0000
#
#-----------------------------------------------------------------
# LIMITATIONS:
# This bootloader assumes a virtual floppy disk, e.g. as provided
# by qemu. In order to support real floppy drive hardware, drive
# motor control needs to added.
#
#-----------------------------------------------------------------
# Author(s): Ralf Reutemann
#
# $Id: bootload.s,v 1.7 2014/03/30 07:55:33 ralf Exp ralf $
#
#-----------------------------------------------------------------
# Based on cs630ipl.s and memsize.s written by Allan Cruse,
# University of San Francisco, Course CS 630, Fall 2008
#-----------------------------------------------------------------

        #----------------------------------------------------------
        # generate 16-bit code (x86 'real-mode')
        #----------------------------------------------------------
        .code16
        .section        .text

        #----------------------------------------------------------
        # Tell the assembler that our code starts at offset 0.
        # By doing so, our code can easily be relocated by changing
        # the value of the segment register. This offset can also
        # be passed to the linker using the -Ttext option.
        #----------------------------------------------------------
        .org 0

        .global _start
_start:
        #----------------------------------------------------------
        # We better not rely on any particular value of the code
        # segment register CS and therefore use a far jump to load
        # CS and IP with the appropriate values.
        #----------------------------------------------------------
        ljmp   $0x07C0, $mystart
        #----------------------------------------------------------
mystart:
        #----------------------------------------------------------
        # initialize our stack-pointer for servicing interrupts
        #----------------------------------------------------------
        xor     %ax, %ax                # address lowest arena
        mov     %ax, %ss                #   with SS register
        mov     $0x7C00, %sp            # stack is beneath code

        #----------------------------------------------------------
        # enable external interrupts
        #----------------------------------------------------------
        sti

        #----------------------------------------------------------
        # setup segment-registers to address our program-data
        #----------------------------------------------------------
        mov     %cs, %ax                # address program data
        mov     %ax, %ds                # with DS register
        mov     %ax, %es                #   also ES register

        #----------------------------------------------------------
        # clear the screen
        #----------------------------------------------------------
        mov     $0x0F, %ah
        int     $0x10
        xor     %ah, %ah
        int     $0x10

        #----------------------------------------------------------
        # invoke ROM-BIOS service to obtain memory-size (in KB) and
        # use repeated division by ten to convert the value found
        # in AX to a decimal digit-string (without leading zeros)
        #----------------------------------------------------------
        int     $0x12                   # get ram's size into AX
        mov     $5, %di                 # initialize buffer-index
nxdgt:  xor     %dx, %dx                # extend AX to doubleword
        divw    ten                     # divide by decimal radix
        add     $'0', %dl               # convert number to ascii
        dec     %di                     # buffer-index moved left
        mov     %dl, mbuf(%di)          # store numeral in buffer
        or      %ax, %ax                # was the quotient zero?
        jnz     nxdgt                   # no, get another numeral

        lea     mmsg, %bp               # message-offset in BP
        mov     mmlen, %cx              # message-length in CX
        call    showmsg
        #----------------------------------------------------------

        #----------------------------------------------------------
        # read sectors from floppy disk into memory one single
        # sector at a time
        #----------------------------------------------------------
        mov     $1, %cx
readloop:
        push    %cx                     # put parameter on stack
        call    read_one_sector
        add     $2, %sp                 # remove parameter again
        inc     %cx
        cmp     $512, %cx
        jbe     readloop

        #----------------------------------------------------------
        # check for our application signature
        #----------------------------------------------------------
        les     progloc, %di            # point ES:DI to program location
        cmpw    $0xCAFE, %es:(%di)      # our signature there?
        mov     %es:2(%di), %ax         # store segment offset
        je      load_prog               # yes, load program

        #----------------------------------------------------------
        # check for orignal USF signature
        #----------------------------------------------------------
        les     progloc, %di            # point ES:DI to program location
        cmpw    $0xABCD, %es:(%di)      # our signature there?
        jne     inval                   # no, format not valid
        mov     $2, %ax

load_prog:
        #----------------------------------------------------------
        # push segment and address offset of return location
        #----------------------------------------------------------
        pushw   %cs
        pushw   $cleanup
        #----------------------------------------------------------
        # push segment and address offset of target location
        #----------------------------------------------------------
        pushw   %es
        pushw   %ax
        #----------------------------------------------------------
        # jump to target location
        #----------------------------------------------------------
        lret
cleanup:
        #----------------------------------------------------------
        # accommodate 'quirk' in some ROM-BIOS service-functions
        #----------------------------------------------------------
        mov     %cs, %ax                # address our variables
        mov     %ax, %ds                #   using DS register
        lgdt    regGDT                  # setup register GDTR
        cli                             # turn off interrupts
        mov     %cr0, %eax              # get machine status
        bts     $0, %eax                # set image of PE-bit
        mov     %eax, %cr0              # enter protected-mode
        mov     $8, %dx                 # descriptor's selector
        mov     %dx, %fs                # for 4GB segment-limit
        mov     %dx, %gs                # both in FS and in GS
        btr     $0, %eax                # reset image of PE-bit
        mov     %eax, %cr0              # leave protected-mode
        sti                             # interrupts on again

        #----------------------------------------------------------
        # show the user our 'reboot' message
        #----------------------------------------------------------
        lea     msg0, %bp               # message-offset in BP
        mov     len0, %cx               # message-length in CX
waitkey:
        call    showmsg
        #----------------------------------------------------------
        # await our user's keypress
        #----------------------------------------------------------
        xor     %ah, %ah                # await keyboard input
        int     $0x16                   # request BIOS service

        #----------------------------------------------------------
        # invoke the ROM-BIOS reboot service to reboot this PC
        #----------------------------------------------------------
        int     $0x19
        #----------------------------------------------------------
        # REBOOT
        #----------------------------------------------------------

#------------------------------------------------------------------
rderr:  lea     msg1, %bp               # message-offset in BP
        mov     len1, %cx               # message-length in CX
        jmp     waitkey
#------------------------------------------------------------------
inval:  lea     msg2, %bp               # message-offset in BP
        mov     len2, %cx               # message-length in CX
        jmp     waitkey
#------------------------------------------------------------------
# Parameters:
#   - "logical" sector number   [bp+4]
#------------------------------------------------------------------
# INT 13,2 - Read Disk Sectors
#
# AH    = 02
# AL    = number of sectors to read  (1-128 dec.)
# CH    = track/cylinder number  (0-1023 dec., see below)
# CL    = sector number  (1-17 dec.)
# DH    = head number  (0-15 dec.)
# DL    = drive number (0=A:, 1=2nd floppy, 80h=drive 0, 81h=drive 1)
# ES:BX = pointer to buffer
#
# Return:
#  AH   = status  (see INT 13,STATUS)
#  AL   = number of sectors read
#  CF   = 0 if successful, 1 if error
#
#  - BIOS disk reads should be retried at least three times and the
#    controller should be reset upon error detection
#  - be sure ES:BX does not cross a 64K segment boundary or a
#    DMA boundary error will occur
#  - many programming references list only floppy disk register values
#  - only the disk number is checked for validity
#  - the parameters in CX change depending on the number of cylinders;
#    the track/cylinder number is a 10 bit value taken from the 2 high
#    order bits of CL and the 8 bits in CH (low order 8 bits of track):
#
#    |F|E|D|C|B|A|9|8|7|6|5-0|  CX
#     | | | | | | | | | |  v-----  sector number
#     | | | | | | | |  v---------  high order 2 bits of track/cylinder
#     +-+-+-+-+-+-+-+------------  low order 8 bits of track/cyl number
#
#------------------------------------------------------------------
read_one_sector:
        push    %bp
        mov     %sp, %bp
        pusha

        #----------------------------------------------------------
        # Sector = log_sec % SECTORS_PER_TRACK
        # Head = (log_sec / SECTORS_PER_TRACK) % HEADS
        # get logical sector number from stack
        #----------------------------------------------------------
        mov     4(%bp), %ax
        xor     %dx, %dx
        mov     $18, %bx
        div     %bx
        mov     %dl, sec
        and     $1, %ax
        mov     %al, head

        #----------------------------------------------------------
        # Track = log_sec / (SECTORS_PER_TRACK*HEADS)
        #----------------------------------------------------------
        mov     4(%bp), %ax
        xor     %dx, %dx
        mov     $18*2, %bx
        div     %bx
        mov     %al, track

        #----------------------------------------------------------
        # load ES:BX with the start address where the sectors
        # from floppy disk will be loaded to
        #----------------------------------------------------------
        les     loadloc, %bx
        #----------------------------------------------------------
        # ah = 0x02 read disk function
        # al = 0x01 read a single sector
        #----------------------------------------------------------
        mov     $0x0201, %ax
        #----------------------------------------------------------
        # read sector into cl and track into ch, combine
        # into a single word read
        #----------------------------------------------------------
        mov     sectrack, %cx
        #----------------------------------------------------------
        # physical sector number starts at 1, so increment
        # logical sector number that has been calculated above
        #----------------------------------------------------------
        inc     %cl
        mov     head, %dh
        #----------------------------------------------------------
        # set drive id to zero (floppy drive)
        #----------------------------------------------------------
        xor     %dl, %dl
        #----------------------------------------------------------
        # use ROM-BIOS service to read from floppy disk
        #----------------------------------------------------------
        int     $0x13
        #----------------------------------------------------------
        # CF is set in case of an error
        #----------------------------------------------------------
        jc      rderr                   # error? exit w/message

        #----------------------------------------------------------
        # increment segmented address by sector size (512 bytes)
        #----------------------------------------------------------
        addw    $0x20, loadloc+2        # add sector size to segment

        popa
        pop     %bp
        ret
#------------------------------------------------------------------
showmsg:
        #----------------------------------------------------------
        # use ROM-BIOS services to write a message to the screen
        #----------------------------------------------------------
        push    %cx                     # preserve string-length
        mov     $0x0F, %ah              # get page-number in BH
        int     $0x10                   # request BIOS service
        mov     $0x03, %ah              # get cursor locn in DX
        int     $0x10                   # request BIOS service
        pop     %cx                     # recover string-length
        mov     %ds, %ax                # address our variables
        mov     %ax, %es                #   using ES register
        mov     $0x0f, %bl              # put text colors in BL
        mov     $0x1301, %ax            # write_string function
        int     $0x10                   # request BIOS service
        ret

#------------------------------------------------------------------
sectrack:           # synonym for word access
sec:    .byte  0    #   will go into cl register
track:  .byte  0    #   will go into ch register
head:   .byte  0
#------------------------------------------------------------------
# This bootloader supports loading programs to two different
# locations in memory, based on a signature word stored in the
# first two bytes of the program image.
#
# Segmented address where to find the program
progloc:.word   0x0000, 0x1000          # offset, segment
#------------------------------------------------------------------
# This is the segmented address where to load the disk-sectors.
# NOTE: this segmented address is updated by the load procedure
# after each read sector, and, finally, points to the memory
# location following the last loaded byte
loadloc:.word   0x0000, 0x07E0          # offset, segment
#------------------------------------------------------------------
msg0:   .ascii  "Hit any key to reboot\r\n"  # message-text
len0:   .short  . - msg0                # length of message-string
msg1:   .ascii  "Read error\r\n"      # message-text
len1:   .short  . - msg1                # length of message-string
msg2:   .ascii  "Signature error\r\n"   # message-text
len2:   .short  . - msg2                # length of message-string
ten:    .short  10                      # decimal-system's radix
mmsg:   .ascii  "\r\n*** DHBW SNP Boot Loader ***\r\n\r\n"
        .ascii  "Real-Mode Memory:"
mbuf:   .ascii  "    0 KB\r\n\n"        # size to report
mmlen:  .short  . - mmsg                # message length
#------------------------------------------------------------------
theGDT: .quad   0, 0x008F92000000FFFF   # has 4GB data-descriptor
regGDT: .word   15, theGDT + 0x7C00, 0  # image for register GDTR
#------------------------------------------------------------------
        .end                            # nothing more to assemble

@


1.7
log
@Moved data definitions to the end of the source file.
Additional comments.
Added support for loading an alternative stage 2 loader.
@
text
@d3 1
a3 1
# bootload.s
d14 2
a15 1
# If a program with signature word 0xCAFE is found at this
d17 1
d19 1
a19 1
# word 0xABCD, and if found, the program located there is
d23 12
a34 1
# NOTE: This code begins executing with CS:IP = 0x07C0:0000
d36 1
a36 1
# $Id:$
d120 1
a120 1
        push    %cx
d127 4
a130 2
        # check for stage 2 loader
        les     stg2loc, %di            # point ES:DI to program location
d132 2
a133 1
        jne     no_stage2               # no, try next start location
d135 3
a137 6
        lcall   $0x07e0, $0x0010
        jmp     cleanup

no_stage2:

        # check for our application signature
d141 1
d143 2
d146 1
d149 3
a151 1
        # push segment and address offset of target locatation
a152 1
        mov     %es:2(%di), %ax
d154 1
d156 1
a157 1

d159 1
d161 1
d176 1
d178 1
d183 1
d185 1
d245 1
d249 1
d258 1
d260 1
d267 1
d270 1
d272 1
d275 1
d277 1
d280 1
d282 1
d285 1
d288 1
d290 1
d292 1
d294 1
d296 1
d298 1
d301 1
d303 1
d311 1
d313 1
d329 2
a330 2
sec:    .byte  0    # will go into cl register
track:  .byte  0    # will go into ch register
d333 5
a337 1
# This is the segmented address where to find the program
a338 2
# This is the segmented address where to find stage 2
stg2loc:.word   0x0000, 0x07E0          # offset, segment
@


1.6
log
@Changed program entry from 'main' to '_start'.
Bootloader clears video screen right after its start.
@
text
@d1 33
a33 19
//-----------------------------------------------------------------
//      bootload.s
//
//      Here is a 'boot-loader' that you can use for launching our
//      programming demos and exercises.
//      This boot-loader first demonstrates use of the ROM-BIOS
//      'Get Memory Size' service (int 0x12) in order to find out
//      the upper limit on memory available for use in real-mode.
//
//        to assemble: $ as cs630ipl.s -o cs630ipl.o
//        and to link: $ ld cs630ipl.o -T ldscript -o cs630ipl.b 
//        and install: $ dd if=cs630ipl.b of=/dev/sda4
//
//      NOTE: This code begins executing with CS:IP = 0000:7C00
//
//      Based on cs630ipl.s and memsize.s written by Allan Cruse,
//      University of San Francisco, Course CS 630, Fall 2008
//-----------------------------------------------------------------
        .code16                         # for x86 'real-mode'
d35 10
a44 20
#------------------------------------------------------------------
start:  ljmp    $0x07C0, $_start        # renormalize CS and IP
#------------------------------------------------------------------
        .ascii  "SNP_2014"              # helps identify presence
#------------------------------------------------------------------
progloc:.word   0x0000, 0x1000          # where to put disk-sector
#------------------------------------------------------------------
msg0:   .ascii  "Hit any key to reboot\r\n"  # message-text
len0:   .short  . - msg0                # length of message-string
msg1:   .ascii  "Read error\r\n"      # message-text
len1:   .short  . - msg1                # length of message-string
msg2:   .ascii  "Signature error\r\n"   # message-text
len2:   .short  . - msg2                # length of message-string
ten:    .short  10                      # decimal-system's radix
mmsg:   .ascii  "\r\n*** DHBW SNP Boot Loader ***\r\n\r\n"
        .ascii  "Real-Mode Memory:"
mbuf:   .ascii  "    0 KB\r\n\n"        # size to report
mmlen:  .short  . - mmsg                # message length
#------------------------------------------------------------------
        .globl  _start
d46 9
d56 1
a59 1
        sti                             # now permit interrupts
d61 6
d68 1
d73 1
d75 1
d81 2
a82 3
        # invoke ROM-BIOS service to obtain memory-size (in KB)
        int     $0x12                   # get ram's size into AX

d85 2
d99 1
d101 4
d108 2
a109 2
        call    readsec
        add     $2, %sp
d111 1
a111 1
        cmp     $128, %cx
d114 10
d129 9
a137 2
startprog:
        lcall   $0x1000, $0x0002        # with call to program
d139 1
d164 5
a168 2
        # invoke the ROM-BIOS reboot service
        int     $0x19                   # reboot this workstation
d170 1
a180 5
sectrack:           # synonym for word access
sec:    .byte  0    # will go into cl register
track:  .byte  0    # will go into ch register
head:   .byte  0
#------------------------------------------------------------------
d184 32
a215 1
readsec:
d238 3
a240 6
        les     progloc, %bx            # load ES:BX
        mov     4(%bp), %ax
        dec     %ax
        shl     $9, %ax
        add     %ax, %bx

d247 2
a248 1
        # physical sector number starts at 1
d253 1
d255 1
d258 3
d279 17
d297 13
a309 1
theGDT: .quad   0, 0x008F92000000FFFF   # has 4GB data-descriptor 
a310 3
#------------------------------------------------------------------
        .org    510                     # offset of boot-signature
        .byte   0x55, 0xAA              # value for boot-signature
@


1.5
log
@The boot-loader now reads 128 sectors (a full 64k segment)
from floppy disk using a function to read one sector at a
time.
@
text
@d22 1
a22 1
start:  ljmp    $0x07C0, $main          # renormalize CS and IP
d40 3
a42 1
main:   # initialize our stack-pointer for servicing interrupts
d52 6
@


1.4
log
@The boot-loader reads 89 consecutive floppy disk sectors.
In addition, the code structure has beed revised and cleaned-up
a bit.
@
text
@d24 1
a24 1
        .ascii  "DHBW SNP 2014"         # helps identify presence
d30 1
a30 1
msg1:   .ascii  "Unable to read from disk\r\n"      # message-text
d32 1
a32 1
msg2:   .ascii  "Wrong signature\r\n"   # message-text
a38 1
att:    .byte   0x0F                    # white upon black
d69 8
a76 59
        # read sectors from floppy disk into es:bx
        # read logical sectors #1 to #17
        les     progloc, %bx            # load ES:BX
        movb    $0x02, %ah              # read disk function
        movb    $0x11, %al              # total sectors to read
        movb    $0x00, %ch              # select cylinder zero
        movb    $0x00, %dh              # select head zero
        movb    $0x02, %cl              # start reading from this sector
        movb    $0x00, %dl              # drive number
        int     $0x13                   # request BIOS service
        jc      rderr                   # error? exit w/message

        # read logical sectors #18 to #35
        les     progloc, %bx            # load ES:BX
        addw    $0x2200, %bx
        movb    $0x02, %ah              # read disk function
        movb    $0x12, %al              # total sectors to read
        movb    $0x00, %ch              # select cylinder zero
        movb    $0x01, %dh              # select head one
        movb    $0x01, %cl              # start reading from this sector
        movb    $0x00, %dl              # drive number
        int     $0x13                   # request BIOS service
        jc      rderr                   # error? exit w/message

        # read logical sectors #36 to #53
        les     progloc, %bx            # load ES:BX
        addw    $0x4600, %bx
        movb    $0x02, %ah              # read disk function
        movb    $0x12, %al              # total sectors to read
        movb    $0x01, %ch              # select cylinder one
        movb    $0x00, %dh              # select head zero
        movb    $0x01, %cl              # start reading from this sector
        movb    $0x00, %dl              # drive number
        int     $0x13                   # request BIOS service
        jc      rderr                   # error? exit w/message

        # read logical sectors #54 to #71
        les     progloc, %bx            # load ES:BX
        addw    $0x6a00, %bx
        movb    $0x02, %ah              # read disk function
        movb    $0x12, %al              # total sectors to read
        movb    $0x01, %ch              # select cylinder one
        movb    $0x01, %dh              # select head one
        movb    $0x01, %cl              # start reading from this sector
        movb    $0x00, %dl              # drive number
        int     $0x13                   # request BIOS service
        jc      rderr                   # error? exit w/message

        # read logical sectors #72 to #89
        les     progloc, %bx            # load ES:BX
        addw    $0x8e00, %bx
        movb    $0x02, %ah              # read disk function
        movb    $0x12, %al              # total sectors to read
        movb    $0x02, %ch              # select cylinder two
        movb    $0x00, %dh              # select head zero
        movb    $0x01, %cl              # start reading from this sector
        movb    $0x00, %dl              # drive number
        int     $0x13                   # request BIOS service
        jc      rderr                   # error? exit w/message
d104 1
a105 2

waitkey:
a116 1
        call    showmsg                 # display that message
a120 1
        call    showmsg                 # display that message
d123 55
d188 1
a188 1
        mov     att, %bl                # put text colors in BL
@


1.3
log
@The boot-loader reads additional sectors and stores them
starting at address 0x12000.
@
text
@d2 1
a2 1
//      cs630ipl.s
d5 4
a8 1
//      CS 630 programming demos and exercises during Fall 2008.
d14 1
a14 1
//      NOTE: This code begins executing with CS:IP = 0000:7C00.
d16 2
a17 5
//      programmer: ALLAN CRUSE
//      written on: 02 FEB 2007
//      revised on: 09 MAR 2007 -- save partition's LBA at 0x004F0
//      revised on: 22 MAR 2007 -- to give 4GB limits to FS and GS 
//      renamed on: 09 SEP 2008 -- for use CS 630 during Fall 2008
d24 1
a24 1
        .ascii  " cs630ipl 09/09/2008 " # helps identify presence 
a26 1
        .quad   0                       # where to get disk-sector
d28 1
a28 3
relLBA: .long   0                       # current disk start-block
#------------------------------------------------------------------
msg0:   .ascii  "Hit any key to reboot system\n\r"  # message-text
d30 1
a30 1
msg1:   .ascii  "Unable to read from disk\n\r"      # message-text
d32 1
a32 1
msg2:   .ascii  "Wrong signature\n\r"   # message-text
d34 6
a39 2
msg3:   .ascii  "Linux partitions not found\n\r"    # message-text
len3:   .short  . - msg3                # length of message-string
d45 1
a45 1
        sti                             # now permit interrupts  
d50 4
d55 17
a72 2

        # read sectors from floppy disk into es:0000
d74 1
a74 1
        movb    $0x10, %al              # total sectors to read
d80 1
a80 1
        jc      rderr                   # error? exit w/message 
d82 3
a84 1
        addw    $0x2000, %bx
d89 37
a125 1
        movb    $0x02, %cl              # start reading from this sector
d128 1
a128 1
        jc      rderr                   # error? exit w/message 
d131 1
a131 1
        les     progloc, %di            # point ES:DI to program location 
a134 16
        jmp     startprog

#------------------------------------------------------------------
rderr:  lea     msg1, %bp               # message-offset in BP
        mov     len1, %cx               # message-length in CX
        jmp     showmsg                 # display that message
#------------------------------------------------------------------
inval:  lea     msg2, %bp               # message-offset in BP
        mov     len2, %cx               # message-length in CX
        jmp     showmsg                 # display that message
#------------------------------------------------------------------
nopte:  lea     msg3, %bp               # message-offset in BP
        mov     len3, %cx               # message-length in CX
        jmp     showmsg                 # display that message
#------------------------------------------------------------------

d146 1
a146 1
        mov     $8, %dx                 # descriptor's selector  
d156 24
a179 2
showmsg: 
        # use ROM-BIOS services to write a message to the screen 
d188 1
a188 1
        mov     $0x0F, %bl              # put text colors in BL
d191 1
a191 7

        # await our user's keypress
        xor     %ah, %ah                # await keyboard input
        int     $0x16                   # request BIOS service

        # invoke the ROM-BIOS reboot service
        int     $0x19                   # reboot this workstation
@


1.2
log
@The boot-loader reads a number of sectors from floppy
disk instead of hard disk.
@
text
@a18 5
        
        # manifest constants
        .equ    DRIVE_ID, 0x80          # BIOS ID-number for disk
        .equ    EDD_READ, 0x42          # 'Read_Sectors' function

d54 1
a54 1
        movb    $0x04, %al              # total sectors to read
d57 10
@


1.1
log
@Initial revision
@
text
@d2 1
a2 1
//	cs630ipl.s
d4 2
a5 2
//	Here is a 'boot-loader' that you can use for launching our
//	CS 630 programming demos and exercises during Fall 2008.
d7 3
a9 3
//	  to assemble: $ as cs630ipl.s -o cs630ipl.o
//	  and to link: $ ld cs630ipl.o -T ldscript -o cs630ipl.b 
//	  and install: $ dd if=cs630ipl.b of=/dev/sda4
d11 1
a11 1
//	NOTE: This code begins executing with CS:IP = 0000:7C00.
d13 5
a17 5
//	programmer: ALLAN CRUSE
//	written on: 02 FEB 2007
//	revised on: 09 MAR 2007 -- save partition's LBA at 0x004F0
//	revised on: 22 MAR 2007 -- to give 4GB limits to FS and GS 
//	renamed on: 09 SEP 2008 -- for use CS 630 during Fall 2008
d19 90
a108 130
	
	# manifest constants
	.equ	DRIVE_ID, 0x80		# BIOS ID-number for disk
	.equ	EDD_READ, 0x42		# 'Read_Sectors' function

	.code16				# for x86 'real-mode'
	.section	.text
#------------------------------------------------------------------
start:	ljmp	$0x07C0, $main		# renormalize CS and IP
#------------------------------------------------------------------
	.ascii	" cs630ipl 09/09/2008 "	# helps identify presence 
#------------------------------------------------------------------
# Our initial Device Address Packet for EDD ROM-BIOS Function 0x42
packet:	.byte	16, 0, 1, 0		# read one 512-byte sector
	.word	0x7E00, 0x0000		# where to put disk-sector
	.quad	0			# where to get disk-sector
#------------------------------------------------------------------
relLBA:	.long	0			# current disk start-block
#------------------------------------------------------------------
msg0:	.ascii	"Hit any key to reboot system\n\r"  # message-text
len0:	.short	. - msg0		# length of message-string
msg1:	.ascii	"Unable to read from disk\n\r"	    # message-text
len1:	.short	. - msg1		# length of message-string
msg2:	.ascii	"Disk program is invalid\n\r"	    # message-text
len2:	.short	. - msg2		# length of message-string
msg3:	.ascii	"Linux partitions not found\n\r"    # message-text
len3:	.short	. - msg3		# length of message-string
#------------------------------------------------------------------
main:	# initialize our stack-pointer for servicing interrupts
	xor	%ax, %ax		# address lowest arena
	mov	%ax, %ss		#   with SS register
	mov	$0x7C00, %sp		# stack is beneath code
	sti				# now permit interrupts  

	# setup segment-registers to address our program-data
	mov	%cs, %ax		# address program data
	mov	%ax, %ds		#   with DS register

	# read boot-record from hard-disk into region at 0x7E00 
again:	movw	$0, %ss:0x7FFE		# boot-signature field
	lea	packet, %si		# point DS:SI to packet
	mov	$DRIVE_ID, %dl		# hard-disk selection 
	mov	$EDD_READ, %ah		# EDD_Read_Sectors
	int	$0x13			# request BIOS service
	jc	rderr			# error? exit w/message 

	# check the boot-record for a valid boot-signature
	cmpw	$0xAA55, %ss:0x7FFE	# boot-signature there?
	jne	inval			# no, exit w/message

	# search the partition-table entries backward
	mov	$1022, %bx		# point DS:BX to signature
	mov	$4, %cx			# number of table entries
nxpte:	sub	$16, %bx		# point to the next entry
	cmpb	$0x05, 4(%bx)		# Extended Partition type?
	je	isext			# yes, need another access
	cmpb	$0x83, 4(%bx)		# Linux Partition type?
	je	found			# Linux Partition found
	loopne	nxpte			# else check next entry
	jmp	nopte			# else exit w/message 	
isext:	# DS:BX points to 'extended' partition table-entry
	# Algoritm:
	#    if this is a 'primary' extended partition, then
	#    change our logical disk's relative starting LBA
	mov	8(%bx), %eax		# get partition base
	add	relLBA, %eax		# add relative start
	cmpl	$0, relLBA		# primary ext-partn?
	jne	inner			# no, retain relLBA
	mov	%eax, relLBA		# else modify relLBA
inner:	mov	%eax, packet+8		# set as packet source
	jmp	again			# get next boot-sector
#------------------------------------------------------------------
rderr:	lea	msg1, %bp		# message-offset in BP
	mov	len1, %cx		# message-length in CX
	jmp	showmsg			# display that message
#------------------------------------------------------------------
inval:	lea	msg2, %bp		# message-offset in BP
	mov	len2, %cx		# message-length in CX
	jmp	showmsg			# display that message
#------------------------------------------------------------------
nopte:	lea	msg3, %bp		# message-offset in BP
	mov	len3, %cx		# message-length in CX
	jmp	showmsg			# display that message
#------------------------------------------------------------------
found:	# DS:BX = table-entry for disk's final linux-partition
	# Algorithm:
	#    adjust packet for reading multiple records
	mov	8(%bx), %eax		# partition starting-LBA
	inc	%eax			# skip past boot-record
	add	%eax, packet+8		# plus disk's start-LBA
	movb	$127, packet+2		# read 127 disk-sectors
	movw	$0x0000, packet+4	# load-address offset
	movw	$0x1000, packet+6	# load-address segment

	# read the CS630 program-blocks into region at 0x10000 
	lea	packet, %si		# point DS:SI to packet
	mov	$DRIVE_ID, %dl		# read first hard-disk 
	mov	$EDD_READ, %ah		# EDD Read_Sectors
	int	$0x13			# request BIOS service
	jc	rderr

	# check for our application signature
	les	packet+4, %di		# point ES:DI to arena
	cmpw	$0xABCD, %es:(%di)	# our signature there?
	jne	inval			# no, format not valid

	# else perform a direct far call to our application
	mov 	packet+8, %ebx		# pass partition's LBA
	dec 	%ebx			# as parameter in EBX
	mov 	%ebx, %ss:0x04F0	# and as ROM-BIOS data
	lcall	$0x1000, $0x0002	# with call to program

	# accommodate 'quirk' in some ROM-BIOS service-functions
	mov	%cs, %ax		# address our variables
	mov	%ax, %ds		#   using DS register
	lgdt	regGDT			# setup register GDTR
	cli				# turn off interrupts
	mov	%cr0, %eax		# get machine status
	bts	$0, %eax		# set image of PE-bit
	mov	%eax, %cr0		# enter protected-mode
	mov	$8, %dx			# descriptor's selector  
	mov	%dx, %fs		# for 4GB segment-limit
	mov	%dx, %gs		# both in FS and in GS
	btr	$0, %eax		# reset image of PE-bit
	mov	%eax, %cr0		# leave protected-mode
	sti				# interrupts on again

	# show the user our 'reboot' message
	lea	msg0, %bp		# message-offset in BP
	mov	len0, %cx		# message-length in CX
d110 19
a128 19
	# use ROM-BIOS services to write a message to the screen 
	push	%cx			# preserve string-length
	mov	$0x0F, %ah		# get page-number in BH
	int	$0x10			# request BIOS service
	mov	$0x03, %ah		# get cursor locn in DX
	int	$0x10			# request BIOS service
	pop	%cx			# recover string-length
	mov	%ds, %ax		# address our variables
	mov	%ax, %es		#   using ES register
	mov	$0x0F, %bl		# put text colors in BL
	mov	$0x1301, %ax		# write_string function
	int	$0x10			# request BIOS service

	# await our user's keypress
	xor	%ah, %ah		# await keyboard input
	int	$0x16			# request BIOS service

	# invoke the ROM-BIOS reboot service
	int	$0x19			# reboot this workstation
d130 2
a131 2
theGDT:	.quad	0, 0x008F92000000FFFF	# has 4GB data-descriptor 
regGDT:	.word	15, theGDT + 0x7C00, 0	# image for register GDTR
d133 2
a134 2
	.org	510			# offset of boot-signature
	.byte	0x55, 0xAA		# value for boot-signature
d136 2
a137 1
	.end				# nothing more to assemble
@
