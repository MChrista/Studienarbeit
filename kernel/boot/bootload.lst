 GNU assembler version 2.24 (x86_64-linux-gnu)
	 using BFD version (GNU Binutils for Ubuntu) 2.24.
 options passed	: --32 -I../inc -almgns=bootload.lst -c 
 input file    	: bootload.s
 output file   	: bootload.o
 target        	: x86_64-pc-linux-gnu
 time stamp    	: 2014-10-15T12:27:04.000+0200

   1              	#-----------------------------------------------------------------
   2              	#
   3              	# bootload.s - PC Bootloader for DHBW Kernel
   4              	#
   5              	#
   6              	# Here is a 'boot-loader' that you can use for launching our
   7              	# programming demos and exercises.
   8              	#
   9              	# This boot-loader first demonstrates use of the ROM-BIOS
  10              	# 'Get Memory Size' service (int 0x12) in order to find out
  11              	# the upper limit on memory available for use in real-mode.
  12              	# Then, it loads a chunk of blocks from floppy disk into
  13              	# memory starting at address 0x07E0:0000.
  14              	#
  15              	# If a program with signature word 0xBEEF is found at this
  16              	# location, this program is executed with CS:IP = 0x07E0:0010.
  17              	#
  18              	# Otherwise, address 0x1000:0000 is checked for signature
  19              	# word 0xCAFE, and if found, the program located there is
  20              	# executed with CS:IP = 0x1000:addr, where the 16-bit start
  21              	# address 'addr' is stored at location 0x1000:0002.
  22              	#
  23              	#-----------------------------------------------------------------
  24              	# NOTES:
  25              	# This code begins executing with CS:IP = 0x07C0:0000
  26              	#
  27              	#-----------------------------------------------------------------
  28              	# LIMITATIONS:
  29              	# This bootloader assumes a virtual floppy disk, e.g. as provided
  30              	# by qemu. In order to support real floppy drive hardware, drive
  31              	# motor control needs to added.
  32              	#
  33              	#-----------------------------------------------------------------
  34              	# Author(s): Ralf Reutemann
  35              	#
  36              	# $Id: bootload.s,v 2.0 2014/10/03 18:59:34 ralf Exp ralf $
  37              	#
  38              	#-----------------------------------------------------------------
  39              	# Based on cs630ipl.s and memsize.s written by Allan Cruse,
  40              	# University of San Francisco, Course CS 630, Fall 2008
  41              	#-----------------------------------------------------------------
  42              	
  43              	        #----------------------------------------------------------
  44              	        # generate 16-bit code (x86 'real-mode')
  45              	        #----------------------------------------------------------
  46              	        .code16
  47              	        .section        .text
  48              	
  49              	        #----------------------------------------------------------
  50              	        # Tell the assembler that our code starts at offset 0.
  51              	        # By doing so, our code can easily be relocated by changing
  52              	        # the value of the segment register. This offset can also
  53              	        # be passed to the linker using the -Ttext option.
  54              	        #----------------------------------------------------------
  55              	        .org 0
  56              	
  57              	        .global _start
  58              	_start:
  59              	        #----------------------------------------------------------
  60              	        # We better not rely on any particular value of the code
  61              	        # segment register CS and therefore use a far jump to load
  62              	        # CS and IP with the appropriate values.
  63              	        #----------------------------------------------------------
  64 0000 EA1000C0 	        ljmp   $0x07C0, $mystart
  64      07
  65              	        #----------------------------------------------------------
  66              	        # Bootloader Signature String
  67              	        #----------------------------------------------------------
  68 0005 44484257 	        .ascii  "DHBWBOOT_V2"
  68      424F4F54 
  68      5F5632
  69              	        .align  8
  70              	        #----------------------------------------------------------
  71              	mystart:
  72              	        #----------------------------------------------------------
  73              	        # initialize our stack-pointer for servicing interrupts
  74              	        #----------------------------------------------------------
  75 0010 31C0     	        xor     %ax, %ax                # address lowest arena
  76 0012 8ED0     	        mov     %ax, %ss                #   with SS register
  77 0014 BC007C   	        mov     $0x7C00, %sp            # stack is beneath code
  78              	
  79              	        #----------------------------------------------------------
  80              	        # enable external interrupts
  81              	        #----------------------------------------------------------
  82 0017 FB       	        sti
  83              	
  84              	        #----------------------------------------------------------
  85              	        # setup segment-registers to address our program-data
  86              	        #----------------------------------------------------------
  87 0018 8CC8     	        mov     %cs, %ax                # address program data
  88 001a 8ED8     	        mov     %ax, %ds                # with DS register
  89 001c 8EC0     	        mov     %ax, %es                #   also ES register
  90              	
  91              	        #----------------------------------------------------------
  92              	        # clear the screen
  93              	        #----------------------------------------------------------
  94 001e B40F     	        mov     $0x0F, %ah
  95 0020 CD10     	        int     $0x10
  96 0022 30E4     	        xor     %ah, %ah
  97 0024 CD10     	        int     $0x10
  98              	
  99              	        #----------------------------------------------------------
 100              	        # invoke ROM-BIOS service to obtain memory-size (in KB) and
 101              	        # use repeated division by ten to convert the value found
 102              	        # in AX to a decimal digit-string (without leading zeros)
 103              	        #----------------------------------------------------------
 104 0026 CD12     	        int     $0x12                   # get ram's size into AX
 105 0028 BF0500   	        mov     $5, %di                 # initialize buffer-index
 106 002b 31D2     	nxdgt:  xor     %dx, %dx                # extend AX to doubleword
 107 002d F7366601 	        divw    ten                     # divide by decimal radix
 108 0031 80C230   	        add     $'0', %dl               # convert number to ascii
 109 0034 4F       	        dec     %di                     # buffer-index moved left
 110 0035 88959B01 	        mov     %dl, mbuf(%di)          # store numeral in buffer
 111 0039 09C0     	        or      %ax, %ax                # was the quotient zero?
 112 003b 75EE     	        jnz     nxdgt                   # no, get another numeral
 113              	
 114 003d 8D2E6801 	        lea     mmsg, %bp               # message-offset in BP
 115 0041 8B0EA601 	        mov     mmlen, %cx              # message-length in CX
 116 0045 E8C300   	        call    showmsg
 117              	        #----------------------------------------------------------
 118              	
 119              	        #----------------------------------------------------------
 120              	        # read sectors from floppy disk into memory one single
 121              	        # sector at a time
 122              	        #----------------------------------------------------------
 123 0048 B90100   	        mov     $1, %cx
 124              	readloop:
 125 004b 51       	        push    %cx                     # put parameter on stack
 126 004c E87800   	        call    read_one_sector
 127 004f 83C402   	        add     $2, %sp                 # remove parameter again
 128 0052 41       	        inc     %cx
 129 0053 81F90002 	        cmp     $512, %cx
 130 0057 76F2     	        jbe     readloop
 131              	
 132              	        #----------------------------------------------------------
 133              	        # check for our application signature
 134              	        #----------------------------------------------------------
 135 0059 C43E2401 	        les     progloc, %di            # point ES:DI to program location
 136 005d 26813DFE 	        cmpw    $0xCAFE, %es:(%di)      # our signature there?
 136      CA
 137 0062 268B4502 	        mov     %es:2(%di), %ax         # store segment offset
 138 0066 740E     	        je      load_prog               # yes, load program
 139              	
 140              	        #----------------------------------------------------------
 141              	        # check for orignal USF signature
 142              	        #----------------------------------------------------------
 143 0068 C43E2401 	        les     progloc, %di            # point ES:DI to program location
 144 006c 26813DCD 	        cmpw    $0xABCD, %es:(%di)      # our signature there?
 144      AB
 145 0071 754A     	        jne     inval                   # no, format not valid
 146 0073 B80200   	        mov     $2, %ax
 147              	
 148              	load_prog:
 149              	        #----------------------------------------------------------
 150              	        # push segment and address offset of return location
 151              	        #----------------------------------------------------------
 152 0076 0E       	        pushw   %cs
 153 0077 687D00   	        pushw   $cleanup
 154              	        #----------------------------------------------------------
 155              	        # push segment and address offset of target location
 156              	        #----------------------------------------------------------
 157 007a 06       	        pushw   %es
 158 007b 50       	        pushw   %ax
 159              	        #----------------------------------------------------------
 160              	        # jump to target location
 161              	        #----------------------------------------------------------
 162 007c CB       	        lret
 163              	cleanup:
 164              	        #----------------------------------------------------------
 165              	        # accommodate 'quirk' in some ROM-BIOS service-functions
 166              	        #----------------------------------------------------------
 167 007d 8CC8     	        mov     %cs, %ax                # address our variables
 168 007f 8ED8     	        mov     %ax, %ds                #   using DS register
 169 0081 0F0116B8 	        lgdt    regGDT                  # setup register GDTR
 169      01
 170 0086 FA       	        cli                             # turn off interrupts
 171 0087 0F20C0   	        mov     %cr0, %eax              # get machine status
 172 008a 660FBAE8 	        bts     $0, %eax                # set image of PE-bit
 172      00
 173 008f 0F22C0   	        mov     %eax, %cr0              # enter protected-mode
 174 0092 BA0800   	        mov     $8, %dx                 # descriptor's selector
 175 0095 8EE2     	        mov     %dx, %fs                # for 4GB segment-limit
 176 0097 8EEA     	        mov     %dx, %gs                # both in FS and in GS
 177 0099 660FBAF0 	        btr     $0, %eax                # reset image of PE-bit
 177      00
 178 009e 0F22C0   	        mov     %eax, %cr0              # leave protected-mode
 179 00a1 FB       	        sti                             # interrupts on again
 180              	
 181              	        #----------------------------------------------------------
 182              	        # show the user our 'reboot' message
 183              	        #----------------------------------------------------------
 184 00a2 8D2E2C01 	        lea     msg0, %bp               # message-offset in BP
 185 00a6 8B0E4301 	        mov     len0, %cx               # message-length in CX
 186              	waitkey:
 187 00aa E85E00   	        call    showmsg
 188              	        #----------------------------------------------------------
 189              	        # await our user's keypress
 190              	        #----------------------------------------------------------
 191 00ad 30E4     	        xor     %ah, %ah                # await keyboard input
 192 00af CD16     	        int     $0x16                   # request BIOS service
 193              	
 194              	        #----------------------------------------------------------
 195              	        # invoke the ROM-BIOS reboot service to reboot this PC
 196              	        #----------------------------------------------------------
 197 00b1 CD19     	        int     $0x19
 198              	        #----------------------------------------------------------
 199              	        # REBOOT
 200              	        #----------------------------------------------------------
 201              	
 202              	#------------------------------------------------------------------
 203 00b3 8D2E4501 	rderr:  lea     msg1, %bp               # message-offset in BP
 204 00b7 8B0E5101 	        mov     len1, %cx               # message-length in CX
 205 00bb EBED     	        jmp     waitkey
 206              	#------------------------------------------------------------------
 207 00bd 8D2E5301 	inval:  lea     msg2, %bp               # message-offset in BP
 208 00c1 8B0E6401 	        mov     len2, %cx               # message-length in CX
 209 00c5 EBE3     	        jmp     waitkey
 210              	#------------------------------------------------------------------
 211              	# Parameters:
 212              	#   - "logical" sector number   [bp+4]
 213              	#------------------------------------------------------------------
 214              	# INT 13,2 - Read Disk Sectors
 215              	#
 216              	# AH    = 02
 217              	# AL    = number of sectors to read  (1-128 dec.)
 218              	# CH    = track/cylinder number  (0-1023 dec., see below)
 219              	# CL    = sector number  (1-17 dec.)
 220              	# DH    = head number  (0-15 dec.)
 221              	# DL    = drive number (0=A:, 1=2nd floppy, 80h=drive 0, 81h=drive 1)
 222              	# ES:BX = pointer to buffer
 223              	#
 224              	# Return:
 225              	#  AH   = status  (see INT 13,STATUS)
 226              	#  AL   = number of sectors read
 227              	#  CF   = 0 if successful, 1 if error
 228              	#
 229              	#  - BIOS disk reads should be retried at least three times and the
 230              	#    controller should be reset upon error detection
 231              	#  - be sure ES:BX does not cross a 64K segment boundary or a
 232              	#    DMA boundary error will occur
 233              	#  - many programming references list only floppy disk register values
 234              	#  - only the disk number is checked for validity
 235              	#  - the parameters in CX change depending on the number of cylinders;
 236              	#    the track/cylinder number is a 10 bit value taken from the 2 high
 237              	#    order bits of CL and the 8 bits in CH (low order 8 bits of track):
 238              	#
 239              	#    |F|E|D|C|B|A|9|8|7|6|5-0|  CX
 240              	#     | | | | | | | | | |  v-----  sector number
 241              	#     | | | | | | | |  v---------  high order 2 bits of track/cylinder
 242              	#     +-+-+-+-+-+-+-+------------  low order 8 bits of track/cyl number
 243              	#
 244              	#------------------------------------------------------------------
 245              	read_one_sector:
 246 00c7 55       	        push    %bp
 247 00c8 89E5     	        mov     %sp, %bp
 248 00ca 60       	        pusha
 249              	
 250              	        #----------------------------------------------------------
 251              	        # Sector = log_sec % SECTORS_PER_TRACK
 252              	        # Head = (log_sec / SECTORS_PER_TRACK) % HEADS
 253              	        # get logical sector number from stack
 254              	        #----------------------------------------------------------
 255 00cb 8B4604   	        mov     4(%bp), %ax
 256 00ce 31D2     	        xor     %dx, %dx
 257 00d0 BB1200   	        mov     $18, %bx
 258 00d3 F7F3     	        div     %bx
 259 00d5 88162101 	        mov     %dl, sec
 260 00d9 83E001   	        and     $1, %ax
 261 00dc A22301   	        mov     %al, head
 262              	
 263              	        #----------------------------------------------------------
 264              	        # Track = log_sec / (SECTORS_PER_TRACK*HEADS)
 265              	        #----------------------------------------------------------
 266 00df 8B4604   	        mov     4(%bp), %ax
 267 00e2 31D2     	        xor     %dx, %dx
 268 00e4 BB2400   	        mov     $18*2, %bx
 269 00e7 F7F3     	        div     %bx
 270 00e9 A22201   	        mov     %al, track
 271              	
 272              	        #----------------------------------------------------------
 273              	        # load ES:BX with the start address where the sectors
 274              	        # from floppy disk will be loaded to
 275              	        #----------------------------------------------------------
 276 00ec C41E2801 	        les     loadloc, %bx
 277              	        #----------------------------------------------------------
 278              	        # ah = 0x02 read disk function
 279              	        # al = 0x01 read a single sector
 280              	        #----------------------------------------------------------
 281 00f0 B80102   	        mov     $0x0201, %ax
 282              	        #----------------------------------------------------------
 283              	        # read sector into cl and track into ch, combine
 284              	        # into a single word read
 285              	        #----------------------------------------------------------
 286 00f3 8B0E2101 	        mov     sectrack, %cx
 287              	        #----------------------------------------------------------
 288              	        # physical sector number starts at 1, so increment
 289              	        # logical sector number that has been calculated above
 290              	        #----------------------------------------------------------
 291 00f7 FEC1     	        inc     %cl
 292 00f9 8A362301 	        mov     head, %dh
 293              	        #----------------------------------------------------------
 294              	        # set drive id to zero (floppy drive)
 295              	        #----------------------------------------------------------
 296 00fd 30D2     	        xor     %dl, %dl
 297              	        #----------------------------------------------------------
 298              	        # use ROM-BIOS service to read from floppy disk
 299              	        #----------------------------------------------------------
 300 00ff CD13     	        int     $0x13
 301              	        #----------------------------------------------------------
 302              	        # CF is set in case of an error
 303              	        #----------------------------------------------------------
 304 0101 72B0     	        jc      rderr                   # error? exit w/message
 305              	
 306              	        #----------------------------------------------------------
 307              	        # increment segmented address by sector size (512 bytes)
 308              	        #----------------------------------------------------------
 309 0103 83062A01 	        addw    $0x20, loadloc+2        # add sector size to segment
 309      20
 310              	
 311 0108 61       	        popa
 312 0109 5D       	        pop     %bp
 313 010a C3       	        ret
 314              	#------------------------------------------------------------------
 315              	showmsg:
 316              	        #----------------------------------------------------------
 317              	        # use ROM-BIOS services to write a message to the screen
 318              	        #----------------------------------------------------------
 319 010b 51       	        push    %cx                     # preserve string-length
 320 010c B40F     	        mov     $0x0F, %ah              # get page-number in BH
 321 010e CD10     	        int     $0x10                   # request BIOS service
 322 0110 B403     	        mov     $0x03, %ah              # get cursor locn in DX
 323 0112 CD10     	        int     $0x10                   # request BIOS service
 324 0114 59       	        pop     %cx                     # recover string-length
 325 0115 8CD8     	        mov     %ds, %ax                # address our variables
 326 0117 8EC0     	        mov     %ax, %es                #   using ES register
 327 0119 B30F     	        mov     $0x0f, %bl              # put text colors in BL
 328 011b B80113   	        mov     $0x1301, %ax            # write_string function
 329 011e CD10     	        int     $0x10                   # request BIOS service
 330 0120 C3       	        ret
 331              	
 332              	#------------------------------------------------------------------
 333              	sectrack:           # synonym for word access
 334 0121 00       	sec:    .byte  0    #   will go into cl register
 335 0122 00       	track:  .byte  0    #   will go into ch register
 336 0123 00       	head:   .byte  0
 337              	#------------------------------------------------------------------
 338              	# This bootloader supports loading programs to two different
 339              	# locations in memory, based on a signature word stored in the
 340              	# first two bytes of the program image.
 341              	#
 342              	# Segmented address where to find the program
 343 0124 00000010 	progloc:.word   0x0000, 0x1000          # offset, segment
 344              	#------------------------------------------------------------------
 345              	# This is the segmented address where to load the disk-sectors.
 346              	# NOTE: this segmented address is updated by the load procedure
 347              	# after each read sector, and, finally, points to the memory
 348              	# location following the last loaded byte
 349 0128 0000E007 	loadloc:.word   0x0000, 0x07E0          # offset, segment
 350              	#------------------------------------------------------------------
 351 012c 48697420 	msg0:   .ascii  "Hit any key to reboot\r\n"  # message-text
 351      616E7920 
 351      6B657920 
 351      746F2072 
 351      65626F6F 
 352 0143 1700     	len0:   .short  . - msg0                # length of message-string
 353 0145 52656164 	msg1:   .ascii  "Read error\r\n"      # message-text
 353      20657272 
 353      6F720D0A 
 354 0151 0C00     	len1:   .short  . - msg1                # length of message-string
 355 0153 5369676E 	msg2:   .ascii  "Signature error\r\n"   # message-text
 355      61747572 
 355      65206572 
 355      726F720D 
 355      0A
 356 0164 1100     	len2:   .short  . - msg2                # length of message-string
 357 0166 0A00     	ten:    .short  10                      # decimal-system's radix
 358 0168 0D0A2A2A 	mmsg:   .ascii  "\r\n*** DHBW SNP Boot Loader ***\r\n\r\n"
 358      2A204448 
 358      42572053 
 358      4E502042 
 358      6F6F7420 
 359 018a 5265616C 	        .ascii  "Real-Mode Memory:"
 359      2D4D6F64 
 359      65204D65 
 359      6D6F7279 
 359      3A
 360 019b 20202020 	mbuf:   .ascii  "    0 KB\r\n\n"        # size to report
 360      30204B42 
 360      0D0A0A
 361 01a6 3E00     	mmlen:  .short  . - mmsg                # message length
 362              	#------------------------------------------------------------------
 363 01a8 00000000 	theGDT: .quad   0, 0x008F92000000FFFF   # has 4GB data-descriptor
 363      00000000 
 363      FFFF0000 
 363      00928F00 
 364 01b8 0F00A87D 	regGDT: .word   15, theGDT + 0x7C00, 0  # image for register GDTR
 364      0000
 365              	#------------------------------------------------------------------
 366              	        .end                            # nothing more to assemble
DEFINED SYMBOLS
          bootload.s:58     .text:0000000000000000 _start
          bootload.s:71     .text:0000000000000010 mystart
          bootload.s:106    .text:000000000000002b nxdgt
          bootload.s:357    .text:0000000000000166 ten
          bootload.s:360    .text:000000000000019b mbuf
          bootload.s:358    .text:0000000000000168 mmsg
          bootload.s:361    .text:00000000000001a6 mmlen
          bootload.s:315    .text:000000000000010b showmsg
          bootload.s:124    .text:000000000000004b readloop
          bootload.s:245    .text:00000000000000c7 read_one_sector
          bootload.s:343    .text:0000000000000124 progloc
          bootload.s:148    .text:0000000000000076 load_prog
          bootload.s:207    .text:00000000000000bd inval
          bootload.s:163    .text:000000000000007d cleanup
          bootload.s:364    .text:00000000000001b8 regGDT
          bootload.s:351    .text:000000000000012c msg0
          bootload.s:352    .text:0000000000000143 len0
          bootload.s:186    .text:00000000000000aa waitkey
          bootload.s:203    .text:00000000000000b3 rderr
          bootload.s:353    .text:0000000000000145 msg1
          bootload.s:354    .text:0000000000000151 len1
          bootload.s:355    .text:0000000000000153 msg2
          bootload.s:356    .text:0000000000000164 len2
          bootload.s:334    .text:0000000000000121 sec
          bootload.s:336    .text:0000000000000123 head
          bootload.s:335    .text:0000000000000122 track
          bootload.s:349    .text:0000000000000128 loadloc
          bootload.s:333    .text:0000000000000121 sectrack
          bootload.s:363    .text:00000000000001a8 theGDT

NO UNDEFINED SYMBOLS
